<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划</title>
      <link href="/2025/03/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2025/03/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划">动态规划</h1><p>动态规划(dynamicprogramming)是运筹学的一个分支，是求解决策过程(decisionprocess)最优化的数学方法。</p><p>20 世纪 50 年代初美国数学家 R.E.Bellman等人在研究多阶段决策过程(multistep decisionprocess)的优化问题时，提出了著名的最优化原理(principle ofoptimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。</p><p>当问题具有最优子结构并且可以使用自底向上方法解决时，使用动态规划。动态规划方法通过两种技术(记忆和制表)扩展了分而治之的方法，这两种技术都具有存储和重用子问题解决方案的目的，可以极大地提高性能。例如，斐波那契函数的朴素递归实现的时间复杂度为<span class="math inline">\(O(2^n)\)</span>，而 DP 解决方案只需要 <spanclass="math inline">\(O(n)\)</span> 时间就可以完成同样的工作。</p><span id="more"></span><p>记忆(自顶向下缓存填充)是指缓存和重用先前计算结果的技术。因此，记忆fib 函数看起来像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">memory_fibonacci</span>(n) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memory[n] is undefined)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) result = n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> result = <span class="built_in">memory_fibonacci</span>(n<span class="number">-2</span>) + <span class="built_in">memory_fibonacci</span>(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        memory[n] = result</span><br><span class="line"></span><br><span class="line">    returnmemory[n]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>制表(自底向上的缓存填充)与此类似，但重点是填充缓存的条目。计算缓存中的值最简单的方法是迭代。fib的制表版本是这样的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">tab_fibnocci</span>(n) &#123;</span><br><span class="line"></span><br><span class="line">    memory[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    memory[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">2.</span>..n</span><br><span class="line"></span><br><span class="line">        memory[i] = memory[i<span class="number">-2</span>] + memory[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    returnmemory[n]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里应该掌握的主要思想是，由于分治问题具有重叠的子问题，因此可以缓存子问题的解决方案，从而实现记忆/制表。</p><h2 id="状态转移方程">状态转移方程</h2><p>动态规划的核心是找到状态转移方程。例如给定一个数字三角形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">3 8</span><br><span class="line"></span><br><span class="line">8 1 0</span><br><span class="line"></span><br><span class="line">2 7 4 4</span><br><span class="line"></span><br><span class="line">4 5 2 6 5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上到下选择一条路，使得经过的数字之和最大。路径上的每一步只能往下或者右下走。</p><p>【递归解法】DFS 深搜</p><p>可以看出每走第 <span class="math inline">\(n\)</span> 行第 <spanclass="math inline">\(m\)</span>列时有两种后续：向下或者向右下。由于最后一行可以确定，当做边界条件，所以我们自然而然想到递归求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">inta[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">intdfs</span>(i, j)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(i == n):</span><br><span class="line"></span><br><span class="line">    returna[i][j];</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">dfs</span>(i<span class="number">+1</span>, j);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> y = <span class="built_in">dfs</span>(i<span class="number">+1</span>, j<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">returnmax</span>(x, y) + a[i][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实仔细观察，上面的解答过程时间复杂度难以想象的大，那是因为对有的数字的解进行了多次的重复计算，如果每次都把结果保存下来，复杂度就会大大降低。</p><p>设 <span class="math inline">\(dp[i][j]\)</span> 表示到达位置 <spanclass="math inline">\((i,j)\)</span> 时获得的最大数字和。显然到达 <spanclass="math inline">\((i,j)\)</span>，只能通过 <spanclass="math inline">\((i-1, j)\)</span> 和 <spanclass="math inline">\((i-1, j-1)\)</span>这两个位置，选择其中最大的并加上当前值即可，所以转移方程为</p><p><span class="math display">\[dp[i][j] = \max(dp[i-1][j], dp[i-1][j-1]) + a[i][j]\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"></span><br><span class="line">      dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + a[i][j]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="背包问题">背包问题</h2><h3 id="背包">0/1 背包</h3><p><strong>题目描述</strong> 给定有 <spanclass="math inline">\(n\)</span> 件物品和一个容量为 <spanclass="math inline">\(C\)</span> 的背包。第 <spanclass="math inline">\(i\)</span> 件物品的体积是 <spanclass="math inline">\(c_i\)</span> ，价值是 <spanclass="math inline">\(v_i\)</span>。将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</p><p><strong>暴力深搜</strong>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是<span class="math inline">\(O(2^n)\)</span>，这里的 <spanclass="math inline">\(n\)</span> 表示物品数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>; <span class="comment">// 记录最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[], <span class="type">int</span> v[];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, C;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯法求解 0/1 背包</span></span><br><span class="line"></span><br><span class="line">voidks_dfs(inti, intj, intk) &#123; <span class="comment">// i 表示物品，j表示容量，k表示当前获得的价值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//已经考虑了n个物品</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line"></span><br><span class="line">        ans = max(ans, k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择当前物品（前提是不会超重）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j + c[i] &lt;= C) &#123;</span><br><span class="line"></span><br><span class="line">        ks_dfs(i + <span class="number">1</span>, j + c[i], k + v[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不选择当前物品</span></span><br><span class="line"></span><br><span class="line">    ks_dfs(i + <span class="number">1</span>, j, k);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</p><p><strong>动态规划</strong> 引入一个二维数组 <spanclass="math inline">\(dp[i][j]\)</span>表示把前 <spanclass="math inline">\(i\)</span> 个(从第 <spanclass="math inline">\(1\)</span> 个到第 <spanclass="math inline">\(i\)</span> 个物品)物品装入容量为 <spanclass="math inline">\(j\)</span> 的背包中获得的最大价值。最后 <spanclass="math inline">\(dp[n][C]\)</span> 就是将 <spanclass="math inline">\(n\)</span> 个物品装入容量为 <spanclass="math inline">\(C\)</span> 的背包获得的最大价值。</p><p><strong>转移方程</strong> 用自底向上的方法计算，如果递推到 <spanclass="math inline">\(dp[i][j]\)</span>，即：将第 <spanclass="math inline">\(i\)</span> 个物品放入到容量为 <spanclass="math inline">\(j\)</span> 的背包，有两种情况：</p><ol type="1"><li><p>第 <span class="math inline">\(i\)</span> 个物品的体积 <spanclass="math inline">\(c[i] &gt;j\)</span>，无法放入背包，那么这是所获得的最大价值等于前 <spanclass="math inline">\(i-1\)</span> 个物品获得的最大价值，即 <spanclass="math inline">\(dp[i][j] = dp[i-1][j]\)</span>。</p></li><li><p>第 <span class="math inline">\(i\)</span> 个物品的体积 <spanclass="math inline">\(c_i \lej\)</span>，可以放入背包。这时候也考虑两种情况：</p><ol type="a"><li><p>如果不加入第 <span class="math inline">\(i\)</span> 个物品，则<span class="math inline">\(dp[i][j] = dp[i-1][j]\)</span>。</p></li><li><p>如果加入第 <span class="math inline">\(i\)</span>个物品，则背包容量减少 <spanclass="math inline">\(c[i]\)</span>，价值增加 <spanclass="math inline">\(v[i]\)</span>，所以获得价值 <spanclass="math inline">\(dp[i][j] = dp[i-1][j-c[i]] +v[i]\)</span>。</p></li></ol></li></ol><p>这时候取这两种情况最大的值，所以转移方程为：</p><p><span class="math display">\[dp[i][j] = max\{dp[i-1][j], dp[i-1][j-c[i]] + v[i]\}\]</span></p><p>例如，<code>c[]=&#123;2, 3, 6, 5&#125;</code>，<code>v[]=&#123;6, 3, 5, 4&#125;</code>，<code>C=9</code>。</p><p><img src="image.png" alt="alt text" /></p><p><strong>递推代码</strong> 自底向上的递推代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">intksi(intn, intC) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//遍历物品</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= C; j++) <span class="comment">//遍历容量</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(c[i] &gt; j) <span class="comment">//放不下</span></span><br><span class="line"></span><br><span class="line">        dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">        dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-c[i]] + v[i]); <span class="comment">//放与不放的最大值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  returndp[n][C];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>递归代码</strong> 自顶向下的记忆化递归代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">intksr(inti, intj) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>) returndp[i][j]; <span class="comment">//注意dp[i][j]需要预先初始化为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) return0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c[i] &gt; j)</span><br><span class="line"></span><br><span class="line">      res = ksr(i<span class="number">-1</span>, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">      res = max(ksr(i<span class="number">-1</span>, j), ksr(i<span class="number">-1</span>, j-c[i]) + v[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    returndp[i][j] = res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>容易得到，上述算法的时间复杂度是 <spanclass="math inline">\(O(nC)\)</span>，空间复杂度也是 <spanclass="math inline">\(O(nC)\)</span>。</p><p><strong>空间优化</strong> 从上面分析过程可以看到转移方程中，计算<span class="math inline">\(dp[i][j]\)</span>时，仅仅与 <spanclass="math inline">\(dp[i-1][j]\)</span>有关，所以通过交替滚动的方式来优化空间。</p><p>定义 <span class="math inline">\(dp[2][j]\)</span>，利用<spanclass="math inline">\(dp[1][j]\)</span> 和 <spanclass="math inline">\(dp[0][j]\)</span>交替滚动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">intdp[<span class="number">2</span>][C+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">intksi(intn, intC) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">      now = i &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= C; j++)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c[i] &gt; j)</span><br><span class="line"></span><br><span class="line">            dp[now][j] = dp[now^<span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">            dp[now][j] = max(dp[now^i][j], dp[now^<span class="number">1</span>][j-c[i]] + v[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    returndp[now][C];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>滚动数组可以用 <code>swap(old, new)</code>方式实现，上面代码中用与和或运算也是一种常见的技巧。</p><p>可以继续优化，用一维数组实现。<strong>注意遍历的顺序是从右到左</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">intdp[C+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">intksi(intn, intC) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = C; j &gt;= c[i]; j--)</span><br><span class="line"></span><br><span class="line">          dp[j] = max(dp[j], dp[j-c[i]] + v[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    returndp[C];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过滚动数组，可以将空间复杂度从 <spanclass="math inline">\(O(nC)\)</span> 优化到 <spanclass="math inline">\(O(C)\)</span>。</p><blockquote><p>几点注意事项：</p></blockquote><blockquote><ol type="1"><li>确定 dp 数组的含义</li></ol></blockquote><blockquote><ol start="2" type="1"><li>找到状态转移方程</li></ol></blockquote><blockquote><ol start="3" type="1"><li>找到递推的起始状态，即初始化 dp 数组</li></ol></blockquote><blockquote><ol start="4" type="1"><li>优化 dp 数组空间</li></ol></blockquote><h3 id="完全背包">完全背包</h3><p><strong>题目描述</strong> 给定有 <spanclass="math inline">\(n\)</span> 种物品和一个容量为 <spanclass="math inline">\(C\)</span> 的背包，每种物品都有无限件可用。第<span class="math inline">\(i\)</span> 种物品的体积是 <spanclass="math inline">\(c_i\)</span> ，价值是 <spanclass="math inline">\(v_i\)</span>。将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</p><p><strong>基本思路</strong> 这个问题非常类似于 01背包问题，所不同的是每种物品有无限件。这时候每种物品取值 <spanclass="math inline">\(k \notin \{0,1\}\)</span>，而是 <spanclass="math inline">\(k \in \{0, 1, \cdots,j/c[i]\}\)</span>。如果仍然按照解 01 背包时的思路，那么转移方程</p><p><span class="math display">\[dp[i][j] = \max\{dp[i-1][j], dp[i-1][j-k*c[i]] + k*v[i]\}, k \in \{0, 1,\cdots, j/c[i]\}\]</span></p><p>时间复杂度是 <span class="math inline">\(O(nC\sumC/c_i)\)</span>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">intksi(intn, intC)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i&lt;= n; i++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span> ; j &lt;= C; j++)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span> ; k*c[i] &lt;= j ; k++)</span><br><span class="line"></span><br><span class="line">        dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j-k*c[i]] + k*v[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  returndp[n][C];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优化思路</strong> 一种启发式优化方法是：若两件物品 <spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(j\)</span>，满足 <span class="math inline">\(c[i]\ge c[j]\)</span>，且 <span class="math inline">\(v[i] \lev[j]\)</span>，则将物品 <span class="math inline">\(i\)</span>去掉，不用考虑。这个优化的正确性显然：更漂亮更聪明的物品总是好的。对于理想情况，可以排除很多不需要考虑的物品，但是最坏情况并不能排除。即漂亮的不聪明，聪明的又不漂亮。</p><p><strong>二进制拆分优化</strong> 考虑一下，若背包容量最多可以放入<span class="math inline">\(\left\lfloor C / c_i\right\rfloor\)</span>个物品 <span class="math inline">\(i\)</span>，假如有 7个，理论上我们需要分别考虑加入 <spanclass="math inline">\(k=0,1,2\cdots7\)</span> 个的情况。如果把 7个物品拆分为，重量为 <span class="math inline">\(c_i, 2c_i,4c_i\)</span>，对应的价值是<span class="math inline">\(v_i, 2v_i,4v_i\)</span>，这新的三个物品的组合可以表示原来的 7 个物品。一般地，把第<span class="math inline">\(i\)</span> 种物品拆成容量为 <spanclass="math inline">\(c_i2^k\)</span>、价值为 <spanclass="math inline">\(v_i2^k\)</span> 的若干件物品，其中 <spanclass="math inline">\(k\)</span> 取遍满足 <spanclass="math inline">\(c_i2^k ≤ C\)</span> 的非负整数。复杂度可以降为<span class="math inline">\(O(C\sum\log(C/c_i)\)</span>。</p><p><strong><span class="math inline">\(O(NC)\)</span> 的算法</strong>考虑 01 背包中的转移方程</p><p><span class="math display">\[dp[i][j] = \max\{dp[i-1][j], {\color{red}{}dp[i-1][j-c[i]]} + v[i]\}\]</span></p><p>只需要修改为</p><p><span class="math display">\[dp[i][j] = \max\{dp[i-1][j], {\color{red}{}dp[i][j-c[i]]} + v[i]\}\]</span></p><p>因为每件物品是无限多种，所以在考虑“加选一件第 <spanclass="math inline">\(i\)</span>种物品”这种策略时，却正需要一个可能已选入第 <spanclass="math inline">\(i\)</span> 种物品的子结果 <spanclass="math inline">\(dp[i][j-c[i]]\)</span>。空间优化时可以简化为（<strong>用纸笔模拟一遍即可明白其中的道理</strong>。）</p><p><span class="math display">\[dp[j] = \max\{dp[j], {\color{red}{}dp[j-c[i]]} + v[i]\}\]</span></p><p>和 01 背包不同的是，遍历时要<strong>从左到右</strong>遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">intcks(intn, intC) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = c[i]; j &lt;= C; j--)</span><br><span class="line"></span><br><span class="line">          dp[j] = max(dp[j], dp[j-c[i]] + v[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    returndp[C];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多重背包">多重背包</h3><p><strong>题目描述</strong> 给定有 <spanclass="math inline">\(n\)</span> 种物品和一个容量为 <spanclass="math inline">\(C\)</span> 的背包。第 <spanclass="math inline">\(i\)</span> 种物品的体积是 <spanclass="math inline">\(c_i\)</span> ，价值是 <spanclass="math inline">\(v_i\)</span>，有 <spanclass="math inline">\(m_i\)</span>个。将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</p><p><strong>基本思路</strong> 和完全背包类似，这是需要考虑 <spanclass="math inline">\(k = 1, 2, \cdots, m_i\)</span>，总的时间复杂度是<span class="math inline">\(O(C\sum m_i)\)</span>。</p><p><span class="math display">\[dp[i][j] = \max\{dp[i-1][v-kc_i] + kv_i) \mid0\le k \le m_i\}\]</span></p><p><strong>二进制拆分</strong> 仍然考虑二进制的思想，考虑把第 i种物品换成若干件物品，使得原问题中第 i 种物品可取的每种策略（取 <spanclass="math inline">\(0\cdots m_i\)</span>件）均能等价于取若干件代换以后的物品。另外，取超过 <spanclass="math inline">\(m_i\)</span> 件的策略必不能出现。将第 <spanclass="math inline">\(i\)</span> 种物品分成若干件 01背包中的物品，其中每件物品有一个系数。这件物品的费用和价值均是原来的费用和价值乘以这个系数。令这些系数分别为<span class="math inline">\(1, 2, 2^2, \cdots, 2^{k−1}, m_i − 2^{k +1}\)</span>，且 <span class="math inline">\(k\)</span> 是满足 <spanclass="math inline">\(m_i − 2^{k + 1} &gt; 0\)</span>的最大整数。例如，如果 <span class="math inline">\(m_i\)</span> 为13，则相应的 <span class="math inline">\(k = 3\)</span>，这种最多取<span class="math inline">\(13\)</span> 件的物品应被分成系数分别为 <spanclass="math inline">\(1, 2, 4, 6\)</span> 的四件物品。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">intksb(intn, intC) &#123;</span><br><span class="line"></span><br><span class="line">  intnc[n * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  intnv[n * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> nn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 二进制拆分</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = m[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= num; num -= k, k*=<span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">      nc[nn] = c[i] * k;</span><br><span class="line"></span><br><span class="line">      nv[nn++] = v[i] * k;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      nc[nn] = c[i] * num;</span><br><span class="line"></span><br><span class="line">      nv[nn++] = v[i] * num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0/1 背包求解</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nn; i++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = C; j &gt;= nc[i]; j--)</span><br><span class="line"></span><br><span class="line">      dp[j] = max(dp[j], dp[j-c[i]] + v[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  returndp[C];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过单调队列优化，可以 <span class="math inline">\(O(nC)\)</span>实现分组背包。</p><h2 id="编辑距离">编辑距离</h2><p><strong>问题背景</strong>编辑距离,也叫莱文斯坦距离(Levenshtein)，在计算语言学和计算机科学中，编辑距离是一个字符串度量，即一种量化两个字符串(如单词)之间的差异性的方法，通过计算将一个字符串转换为另一个字符串所需的最小操作数来测量。编辑距离可以应用自然语言处理中，比如自动拼写纠正，如果你拼写错了一个单词，那么可以从字典中选择与错误单词的编辑距离最近的单词作为纠正的候选单词。在生物信息学中，DNA序列可以看作是字母 A、C、G 和 T 的字符串，编辑距离则可以用来量化 DNA序列的相似性。</p><p><strong>问题描述</strong> 给定两个字符串 <code>a</code> 和<code>b</code>，计算将字符串 <code>a</code> 转换为字符串 <code>b</code>所需要的最少操作。这里的操作是指对字符串 <code>a</code>执行以下三种：</p><ol type="1"><li>删除一个字符；</li><li>插入一个字符；</li><li>替换一个字符。</li></ol><p>例如，<code>a = "sunday"</code>，<code>b = "saturday</code>，这两个字符串第一个和最后三个是相同的，那么只需要将<code>"un"</code> 转换为<code>"atur"</code>。这需要三个操作：1）<code>n</code> 替换为<code>r</code> 变成 <code>ur</code>，2）插入 <code>t</code> 变成<code>tur</code>，3）插入 <code>a</code> 变成 <code>atur</code>。</p><p><strong>基本思路</strong>最简单的思路是从最后一个字符（也可以从第一个字符）枚举所有的可能性。采用递归的方法。令<code>m = a.length(), n = b.length()</code>，函数<code>edit_dist(a, b, m, n)</code> 返回将 <code>a</code> 转换为<code>b</code> 所需要的最少操作数。</p><ol type="1"><li><p>如果最后一个字符相同<code>a[m-1] == b[n-1]</code>，那么不需要考虑最后一个字符，直接处理前一个字符就可以了，即转换为<code>edit_dist(a, b, m-1, n-1)</code>。</p></li><li><p>如果最后一个字符不相同，那么可以通过三个操作来使它们相同。</p><ol type="a"><li><p>删除一个字符，<code>a</code> 少一个，<code>b</code>不变，<code>edit_dist(a, b, m-1, n) + 1</code>;</p></li><li><p>插入一个字符，<code>a</code> 不变，<code>b</code>少一个（因为已经插入一个和 <code>b</code>相同的），<code>edit_dist(a, b, m, n-1) + 1</code>；</p></li><li><p>替换一个字符，<code>a</code> 和 <code>b</code>同时少一个，<code>edit_dist(a, b, m-1, n-1) + 1</code>。</p></li></ol></li></ol><p>进一步考虑可以发现，【1】 和 【2.c】两种情况可以合并为<code>edit_dist(a, b, m-1, n-1) + a[m-1] != b[m-1]</code>。</p><p>边界情况，1）如果 <code>a</code> 为空字符串，那么至少需要插入<code>n</code> 个字符变成 <code>b</code>；2）如果 <code>b</code>为空字符串，那么至少需要删除 <code>m</code> 个字符变成<code>b</code>。</p><p>下面是递归的实现代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">intmin</span>(intx, inty, intz) &#123; <span class="built_in">returnmin</span>(<span class="built_in">min</span>(x, y), z); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">intedit_dist</span>(string&amp;a, string&amp;b, intm, intn)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">returnmin</span>(<span class="built_in">edit_dist</span>(a, b, m<span class="number">-1</span>, n) + <span class="number">1</span>, <span class="comment">// remove</span></span><br><span class="line"></span><br><span class="line">             <span class="built_in">edit_dist</span>(a, b, m, n<span class="number">-1</span>) + <span class="number">1</span>, <span class="comment">// insert</span></span><br><span class="line"></span><br><span class="line">             <span class="built_in">edit_dist</span>(a, b, m<span class="number">-1</span>, n<span class="number">-1</span>) + (a[m<span class="number">-1</span>] == b[m<span class="number">-1</span>]) <span class="comment">// replace</span></span><br><span class="line"></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述算法每一步都需要考虑三种情况，时间复杂度 <spanclass="math inline">\(O(3^{\max(m, n)})\)</span>，空间复杂度 <spanclass="math inline">\(O(\max(m,n))\)</span>。</p><p><strong>优化方法</strong>仔细分析可以发现，递归过程中会重复计算很多相同的情况，所以只需要加上记忆化即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dp[M<span class="number">+1</span>][N<span class="number">+1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">intmin</span>(intx, inty, intz) &#123; <span class="built_in">returnmin</span>(<span class="built_in">min</span>(x, y), z); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">intedit_dist</span>(string&amp;a, string&amp;b, intm, intn)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dp[m][n]) returndp[m][n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">0</span>)  returndp[m][n] = n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>)  returndp[m][n] = m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  returndp[m][n] = <span class="built_in">min</span>(<span class="built_in">edit_dist</span>(a, b, m<span class="number">-1</span>, n) + <span class="number">1</span>, <span class="comment">// remove</span></span><br><span class="line"></span><br><span class="line">                        <span class="built_in">edit_dist</span>(a, b, m, n<span class="number">-1</span>) + <span class="number">1</span>, <span class="comment">// insert</span></span><br><span class="line"></span><br><span class="line">                        <span class="built_in">edit_dist</span>(a, b, m<span class="number">-1</span>, n<span class="number">-1</span>) + (a[m<span class="number">-1</span>] != b[n<span class="number">-1</span>]) <span class="comment">// replace</span></span><br><span class="line"></span><br><span class="line">                       );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以写成递推形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dp[M<span class="number">+1</span>][N<span class="number">+1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">intmin</span>(intx, inty, intz) &#123; <span class="built_in">returnmin</span>(<span class="built_in">min</span>(x, y), z); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">intedit_dist</span>(string&amp;a, string&amp;b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> m = a.<span class="built_in">length</span>(), n = b.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"></span><br><span class="line">    dp[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"></span><br><span class="line">      dp[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">      dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j] + <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">                     dp[i][j<span class="number">-1</span>] + <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">                     dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + (a[i<span class="number">-1</span>] != b[j<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  returndp[m][n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优化后时间复杂度和空间度都是 <spanclass="math inline">\(O(mn)\)</span>。</p><p>因为每一次计算仅与前一行和当前行有关系，所以可以进一步采用交替滚动数组将空间复杂度优化到<span class="math inline">\(O(n)\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dp[<span class="number">2</span>][N<span class="number">+1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">intmin</span>(intx, inty, intz) &#123; <span class="built_in">returnmin</span>(<span class="built_in">min</span>(x, y), z); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">intedit_dist</span>(string&amp;a, string&amp;b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = a.<span class="built_in">length</span>(), n = b.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//init pre row</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"></span><br><span class="line">      dp[pre][j] = j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"></span><br><span class="line">      dp[cur][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"></span><br><span class="line">        dp[cur][j] = <span class="built_in">min</span>(dp[pre][j] + <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">                         dp[cur][j<span class="number">-1</span>] + <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">                         dp[pre][j<span class="number">-1</span>] + (a[i<span class="number">-1</span>] != b[j<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">                      );</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">swap</span>(pre, cur);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  returndp[pre][n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="最长公共子序列longest-common-subsequence">最长公共子序列(LongestCommon Subsequence)</h2><p>一个字符串的<strong>子序列</strong>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p><strong>问题描述</strong> 给定两个字符串 <code>a</code> 和<code>b</code>，计算这两个字符串的最长公共子序列的长度。如果不存在公共子序列，则长度为0。</p><p><strong>基本思路</strong>这个问题和【编辑距离】问题类似，只不过只有一个 <code>删除</code>操作。令 <span class="math inline">\(dp[i][j]\)</span> 表示表示字符串<code>a[1...i]</code> 和字符串 <code>b[1...j]</code>的最长公共子序列，那么 <span class="math inline">\(dp[m][n]\)</span>就是 <code>a</code> 和 <code>b</code> 的最长公共子序列。</p><p>问题分为两种情况：</p><ol type="1"><li>当 <span class="math inline">\(a[i] =b[j]\)</span>，那么最长公共子序列的长度可以加 1，即 <spanclass="math inline">\(dp[i][j] = dp[i-1][j-1] + 1\)</span>。</li><li>当 <span class="math inline">\(a[i] \neb[j]\)</span>，这时有两种选择，删除 <spanclass="math inline">\(a[i]\)</span> 或者删除 <spanclass="math inline">\(b[j]\)</span>，选择最大的情况，即 <spanclass="math inline">\(dp[i][j] = max(dp[i-1][j],dp[i][j-1])\)</span>。（<code>能不能同时删除？</code>）</li></ol><p>边界条件，如果有一个字符串为空，那么显然没有公共子序列，直接返回0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dp[<span class="number">2</span>][N<span class="number">+1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">intmin</span>(intx, inty, intz) &#123; <span class="built_in">returnmin</span>(<span class="built_in">min</span>(x, y), z); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">intlcs</span>(string&amp;a, string&amp;b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> m = a.<span class="built_in">length</span>(), n = b.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(a[i<span class="number">-1</span>] == b[j<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        dp[cur][j] = dp[pre][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">        dp[cur][j] = <span class="built_in">max</span>(dp[cur][j<span class="number">-1</span>], dp[pre][j]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(pre, cur);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  returndp[pre][n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数位-dp">数位 DP</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第四讲-动态规划与背包思想</title>
      <link href="/2025/03/20/%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E8%83%8C%E5%8C%85%E6%80%9D%E6%83%B3/"/>
      <url>/2025/03/20/%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E8%83%8C%E5%8C%85%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="作业链接">作业链接</h1><p><a href="https://www.luogu.com.cn/training/714980">[蓝桥杯]第四讲：动态规划与背包思想 - 题单 - 洛谷 | 计算机科学教育新生态</a></p><h1 id="ac-代码">AC 代码</h1><span id="more"></span><h2 id="b3637-最长上升子序列---洛谷"><ahref="https://www.luogu.com.cn/problem/B3637">B3637 最长上升子序列 -洛谷</a></h2><p>问题类型：最长上升子序列（LIS）</p><p>解题思路：</p><ul><li>维护一个动态数组 ans，记录当前可能的递增序列。</li><li>遍历每个数，若该数大于 ans 的末尾元素，直接加入；否则，用该数替换ans 中第一个大于等于它的元素。</li><li>最终 ans 的长度即为最长上升子序列的长度。</li></ul><p>关键点：贪心策略结合二分查找优化时间复杂度到 O(n log n)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (ans.<span class="built_in">empty</span>() || ans.<span class="built_in">back</span>() &lt; x) &#123;</span><br><span class="line">ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> idx = <span class="built_in">lower_bound</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), x) - ans.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//cout &lt;&lt; idx &lt;&lt; endl;</span></span><br><span class="line">ans[idx] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">m = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">    pos = bisect.bisect_left(a, x)</span><br><span class="line">    <span class="keyword">if</span> pos == <span class="built_in">len</span>(a):</span><br><span class="line">        a.append(x)</span><br><span class="line">    <span class="keyword">elif</span> a[pos] &gt; x:</span><br><span class="line">        a[pos] = x  <span class="comment"># 仅当 a[pos] &gt; x 时才替换（去重）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))</span><br></pre></td></tr></table></figure><h2 id="p8707-蓝桥杯-2020-省-ab1-走方格---洛谷"><ahref="https://www.luogu.com.cn/problem/P8707">P8707 [蓝桥杯 2020 省 AB1]走方格 - 洛谷</a></h2><p>问题类型：网格路径计数（动态规划）</p><p>解题思路：</p><ul><li>定义 <code>dp[i][j]</code> 为到达坐标 (i,j) 的路径数。</li><li>初始化起点 <code>dp[i][j]</code> = 1。</li><li>若当前格子行列均为偶数，则不可达（<code>dp[i][j]</code> =0）；否则，路径数由上方和左方转移而来。</li><li>最终输出 <code>dp[n][m]</code>。</li></ul><p>关键点：处理禁止位置并累加有效路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="type">int</span> n,m,dp[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j  = <span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;j%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">and</span> j == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> j % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            dp[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(dp[n][m])</span><br></pre></td></tr></table></figure><h2 id="p8786-蓝桥杯-2022-省-b-李白打酒加强版---洛谷"><ahref="https://www.luogu.com.cn/problem/P8786">P8786 [蓝桥杯 2022 省 B]李白打酒加强版 - 洛谷</a></h2><p>问题类型：三维动态规划（状态转移）</p><p>解题思路：</p><ul><li>状态 <code>f[i][j][k]</code> 表示遇到 <code>i</code>次店、<code>j</code> 次花，剩余酒量为 <code>k</code> 的方案数。</li><li>转移分两种情况：遇到店（酒量翻倍）或遇到花（酒量减 1）。</li><li>最终结果为最后一次遇到花后的状态 <code>f[n][m-1][1]</code>（剩余 1斗酒）。</li></ul><p>关键点：合法状态转移及边界条件处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span><span class="number">+9</span>,M =  <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> f[N][N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k&lt;=m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> &amp;val = f[i][j][k];</span><br><span class="line">                <span class="keyword">if</span>(i&amp;&amp;k%<span class="number">2</span>==<span class="number">0</span>) val = (val+f[i<span class="number">-1</span>][j][k/<span class="number">2</span>])%M;</span><br><span class="line">                <span class="keyword">if</span>(j) val = (val+f[i][j<span class="number">-1</span>][k<span class="number">+1</span>])%M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">f = [[[<span class="number">0</span>]*(m+<span class="number">2</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)] <span class="keyword">for</span> __ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> k % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                f[i][j][k] = (f[i][j][k] + f[i-<span class="number">1</span>][j][k//<span class="number">2</span>]) % MOD</span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> k + <span class="number">1</span> &lt;= m:</span><br><span class="line">                f[i][j][k] = (f[i][j][k] + f[i][j-<span class="number">1</span>][k+<span class="number">1</span>]) % MOD</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f[n][m-<span class="number">1</span>][<span class="number">1</span>] % MOD)</span><br></pre></td></tr></table></figure><h2 id="p1048-noip-2005-普及组-采药---洛谷"><ahref="https://www.luogu.com.cn/problem/P1048">P1048 [NOIP 2005 普及组]采药 - 洛谷</a></h2><p>问题类型：01 背包问题</p><p>解题思路：</p><ul><li>将时间视为背包容量，每株草药的价值为收益。</li><li>一维数组优化，逆序遍历时间避免重复选择。</li><li>状态转移方程：<code>dp[j] = max(dp[j], dp[j - time] + value)</code>。</li><li>输出 <code>dp[t]</code> 即最大总价值。</li></ul><p>关键点：经典 01 背包实现，空间优化技巧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> w[N], v[N], dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = t; j &gt;= w[i]; j--) &#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[t];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">dp = [<span class="number">0</span>]*(t+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    cost, val = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(t, cost-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j-cost] + val)</span><br><span class="line"><span class="built_in">print</span>(dp[t])</span><br></pre></td></tr></table></figure><h2 id="p8742-蓝桥杯-2021-省-ab-砝码称重---洛谷"><ahref="https://www.luogu.com.cn/problem/P8742">P8742 [蓝桥杯 2021 省 AB]砝码称重 - 洛谷</a></h2><p>问题类型：带权 01 背包（左右放置） 解题思路：</p><ul><li>每个砝码可放左、右或不用，状态转移需考虑加减当前重量。</li><li>二维状态 <code>dp[i][j]</code> 表示前 i 个砝码能否组成质量差j。</li><li>最终统计所有可能的质量差。</li></ul><p>关键点：状态转移包含加减操作，注意绝对值处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span><span class="number">+9</span>, M = <span class="number">1e5</span><span class="number">+9</span>;</span><br><span class="line"><span class="type">int</span> w[N], ans;</span><br><span class="line"><span class="type">bool</span> dp[N][M]; <span class="comment">// dp[i][j] = 1 表示枚举到第 i 个砝码，质量 j 可以被表示</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 01 背包</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 可以称出的重量就是左侧砝码的总重量与右侧砝码的总重量之差的绝对值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = M; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i - <span class="number">1</span>][j])dp[i][j] = <span class="number">1</span>; <span class="comment">// 不需要放</span></span><br><span class="line"><span class="keyword">if</span> (j == w[i])dp[i][j] = <span class="number">1</span>; <span class="comment">// 只放当前这一个砝码</span></span><br><span class="line"><span class="keyword">if</span> (dp[i - <span class="number">1</span>][j + w[i]])dp[i][j] = <span class="number">1</span>; <span class="comment">// 去掉 w[i]</span></span><br><span class="line"><span class="keyword">if</span> (dp[i - <span class="number">1</span>][<span class="built_in">abs</span>(j - w[i])])dp[i][j] = <span class="number">1</span>; <span class="comment">// 加上 w[i]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; M; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[n][i])ans++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">w = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">M = <span class="number">10</span>**<span class="number">5</span> + <span class="number">9</span></span><br><span class="line">dp = [[<span class="literal">False</span>]*M <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        <span class="keyword">if</span> dp[i-<span class="number">1</span>][j]:</span><br><span class="line">            dp[i][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> j + w[i-<span class="number">1</span>] &lt; M:</span><br><span class="line">                dp[i][j + w[i-<span class="number">1</span>]] = <span class="literal">True</span></span><br><span class="line">            dp[i][<span class="built_in">abs</span>(j - w[i-<span class="number">1</span>])] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(dp[n][<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure><h2 id="p2347-noip-1996-提高组-砝码称重---洛谷"><ahref="https://www.luogu.com.cn/problem/P2347">P2347 [NOIP 1996 提高组]砝码称重 - 洛谷</a></h2><p>问题类型：多重背包问题</p><p>解题思路：</p><ul><li>遍历每种砝码，枚举其数量，更新可能的质量组合。</li><li>使用布尔数组 dp 记录可组成的质量。</li><li>最终统计 dp 中为 true 的非零元素数量。</li></ul><p>关键点：多重背包转化为 01 背包处理，注意组合方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> w[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>&#125;, a[<span class="number">10</span>], ans;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span><span class="number">+40</span>;</span><br><span class="line"><span class="type">bool</span> dp[N]; <span class="comment">// dp[i] = 1 表示质量 i 可以被组合出来</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123; <span class="comment">// 6 种砝码</span></span><br><span class="line">cin &gt;&gt; a[i]; <span class="comment">// 第 i 种砝码有 a[i] 个</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多重背包：枚举每个砝码，从大到小枚举可以组合出来的质量</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化：一个都不选也是可以组合的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a[i]; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1000</span>; k &gt;= <span class="number">0</span>; k--) &#123;<span class="comment">// 最大质量为 1e3</span></span><br><span class="line"><span class="keyword">if</span> (dp[k]) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; w[i] &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">dp[k + w[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但在计算结果时不能考虑 dp[0] 因为题目强调不包括一个也不用的情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i])ans++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Total=&quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">w = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">dp = [<span class="literal">False</span>]*(<span class="number">1001</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">    count = a[i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[j] <span class="keyword">and</span> j + w[i] &lt;= <span class="number">1000</span>:</span><br><span class="line">                dp[j + w[i]] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Total=<span class="subst">&#123;<span class="built_in">sum</span>(dp[<span class="number">1</span>:])&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="p1616-疯狂的采药---洛谷"><ahref="https://www.luogu.com.cn/problem/P1616">P1616 疯狂的采药 -洛谷</a></h2><p>问题类型：完全背包问题</p><p>解题思路：</p><ul><li>允许无限地重复选择物品，正序遍历时间以支持多次选取。</li><li>状态转移方程：<code>dp[j] = max(dp[j], dp[j - time] + value)</code>。</li><li>输出最大价值 <code>dp[t]</code>。</li></ul><p>关键点：完全背包的正序更新策略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//完全背包问题</span></span><br><span class="line"><span class="type">int</span> t, m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>, T = <span class="number">1e7</span> + <span class="number">9</span>;</span><br><span class="line">ll val[N], cost[N], f[T];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cin &gt;&gt; cost[i] &gt;&gt; val[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = cost[i]; j &lt;= t; j++) &#123;</span><br><span class="line"><span class="comment">//正序推，每个f[j]可以看作f[i-1][j]</span></span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j - cost[i]] + val[i]);<span class="comment">//可以多选一个</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[t];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">dp = [<span class="number">0</span>]*(t+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    cost, val = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cost, t+<span class="number">1</span>):</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - cost] + val)</span><br><span class="line"><span class="built_in">print</span>(dp[t])</span><br></pre></td></tr></table></figure><h2 id="p8646-蓝桥杯-2017-省-ab-包子凑数---洛谷"><ahref="https://www.luogu.com.cn/problem/P8646">P8646 [蓝桥杯 2017 省 AB]包子凑数 - 洛谷</a></h2><p>问题类型：数论+完全背包</p><p>解题思路：</p><ul><li>若所有数互质（GCD 为 1），则存在最大不可组成的数，否则无限。</li><li>完全背包标记可组成的数，统计未被标记的数量。</li><li>使用布尔数组 dp 记录能组成的数。</li></ul><p>关键点：裴蜀定理特判及完全背包求解。</p><h3 id="关于第二重循环只需要枚举到-nn-的说明">关于第二重循环只需要枚举到<span class="math inline">\(N*N\)</span> 的说明</h3><p>由<ahref="https://www.luogu.com.cn/problem/P3951">小凯的疑惑</a>可知：两个互质的数字<span class="math inline">\(p,q\)</span>，不能表示的最大数是 <spanclass="math inline">\(p*q -q-p\)</span>，因此本题中：两个互质的数不能表示的最大数不会大于 <spanclass="math inline">\(N*N-2 \times N\)</span>，即不会大于 <spanclass="math inline">\(N*N\)</span>。同时我们发现，三个互质的数所不能表示的数，一定不会大于两个互质的数所不能表示的数。因为新增一个数字，能表示的数一定不会变少，即不会出现原来能表示的数变得不能表示了，也就是说，上界<span class="math inline">\(p*q - q-p\)</span> 一定不会上移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数论 + 背包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n 种蒸笼，每个可以放 ai 个包子，蒸笼的数量是无限的</span></span><br><span class="line"><span class="comment">求有哪些 A 不能被 a1 * x1 + a2 * x2 + ai * xi + ... + an * xn 表示出来</span></span><br><span class="line"><span class="comment">最简单的情况是两数之和为给定两个种蒸笼 a,b 其可以组合出：ax + by = m</span></span><br><span class="line"><span class="comment">形式符合裴蜀定理，但要注意的是本题中 x,y 不能为负数，因此即使 gcd(ai) = 1 也不说明所有的整数都能被组合出来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> n, ans, flg = <span class="number">0</span>; <span class="comment">// 初始化为 0 避免对结果造成影响</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span><span class="number">+9</span>, M = <span class="number">1e5</span><span class="number">+9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">bool</span> dp[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="comment">//flg = __gcd(flg,a[i]);</span></span><br><span class="line">flg = <span class="built_in">gcd</span>(flg, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flg != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 说明 ai 中的数字不是互质的，则必定有一些质数及它们的倍数无法被描述，因此无法被组合的数字个数为无限</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;INF&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化，默认 0 个包子是可以被组合出来的</span></span><br><span class="line"><span class="comment">// 枚举所有的数字</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = a[i]; j &lt; M; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[j - a[i]])dp[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!dp[i])ans++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a = [<span class="built_in">int</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">gcd_all = a[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> a[<span class="number">1</span>:]:</span><br><span class="line">    gcd_all = math.gcd(gcd_all, num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gcd_all != <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;INF&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    max_val = <span class="number">10</span>**<span class="number">5</span></span><br><span class="line">    dp = [<span class="literal">False</span>]*(max_val + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num, max_val + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[j - num]:</span><br><span class="line">                dp[j] = <span class="literal">True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="keyword">not</span> x <span class="keyword">for</span> x <span class="keyword">in</span> dp[<span class="number">1</span>:max_val + <span class="number">1</span>]))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计竞赛 </category>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计竞赛 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三讲-贪心、模拟与二分</title>
      <link href="/2025/03/11/%E7%AC%AC%E4%B8%89%E8%AE%B2-%E8%B4%AA%E5%BF%83%E3%80%81%E6%A8%A1%E6%8B%9F%E4%B8%8E%E4%BA%8C%E5%88%86/"/>
      <url>/2025/03/11/%E7%AC%AC%E4%B8%89%E8%AE%B2-%E8%B4%AA%E5%BF%83%E3%80%81%E6%A8%A1%E6%8B%9F%E4%B8%8E%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="作业链接">作业链接</h1><p><a href="https://www.luogu.com.cn/training/714877#problems">[蓝桥杯]第三讲：贪心、模拟与二分 - 题单 - 洛谷 | 计算机科学教育新生态</a></p><h1 id="ac-代码">AC 代码</h1><span id="more"></span><h2 id="p8697-蓝桥杯-2019-国-c-最长子序列---洛谷"><ahref="https://www.luogu.com.cn/problem/P8697">P8697 [蓝桥杯 2019 国 C]最长子序列 - 洛谷</a></h2><p>双指针分别维护当前枚举到的 s 和 t 串的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s, t;</span><br><span class="line"><span class="type">int</span> n, m, i = <span class="number">0</span>, j = <span class="number">0</span>, ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">j++;</span><br><span class="line"><span class="comment">//ans++;</span></span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s[i] &lt;&lt; &quot; &quot; &lt;&lt; t[j] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; j;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">t = <span class="built_in">input</span>()</span><br><span class="line">n, m = <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">    <span class="keyword">if</span> s[i] == t[j]:</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(j)</span><br></pre></td></tr></table></figure><h2 id="p1106-删数问题---洛谷"><ahref="https://www.luogu.com.cn/problem/P1106">P1106 删数问题 -洛谷</a></h2><p>由于数字太大，C++ 中无法表示这种数值。</p><p>要求删除后的数字更小，显然应该删除大的数字。考虑到删除数字后原始顺序不变，故高位的数字影响比低位要大。综合来看，可以从高位向低位（高位影响大）遍历，当遇到单调增加的顶点时（大数字）就将其删除。这个做法可以保证每一次得到的结果都是删一个数字时最优的，从而可以得知最终的答案也是最优的。</p><p><del>2024 年算法设计与分析期末原题</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//找高峰</span></span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; k;</span><br><span class="line"><span class="keyword">while</span> (k) &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (s[i] &lt;= s[i + <span class="number">1</span>]) i++; <span class="comment">//i会一直加，直到一个当前单调的最大值</span></span><br><span class="line">s.<span class="built_in">erase</span>(i, <span class="number">1</span>); <span class="comment">//erase删除第i个位置往后长度为1的部分</span></span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (s.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) s.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 消除前导零</span></span><br><span class="line">cout &lt;&lt; s;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> k:</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) - <span class="number">1</span> <span class="keyword">and</span> s[i] &lt;= s[i + <span class="number">1</span>]:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    s = s[:i] + s[i + <span class="number">1</span>:]</span><br><span class="line">    k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">s = s.lstrip(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s <span class="keyword">if</span> s <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="p1090-noip-2004-提高组-合并果子---洛谷"><ahref="https://www.luogu.com.cn/problem/P1090">P1090 [NOIP 2004 提高组]合并果子 - 洛谷</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, x, ans;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">q.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">auto</span> t1 = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">auto</span> t2 = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">ans += t1 + t2;</span><br><span class="line">q.<span class="built_in">push</span>(t1 + t2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">q = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    heapq.heappush(q, x)</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(q) &gt; <span class="number">1</span>:</span><br><span class="line">    t1 = heapq.heappop(q)</span><br><span class="line">    t2 = heapq.heappop(q)</span><br><span class="line">    ans += t1 + t2</span><br><span class="line">    heapq.heappush(q, t1 + t2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h2 id="p8769-蓝桥杯-2021-国-c-巧克力---洛谷"><ahref="https://www.luogu.com.cn/problem/P8769">P8769 [蓝桥杯 2021 国 C]巧克力 - 洛谷</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  有保质期 -&gt; 时间倒流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> day, n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">ll a, b, c;</span><br><span class="line">&#125;;</span><br><span class="line">ll ans, idx = <span class="number">1</span>;</span><br><span class="line">node food[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.b &gt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较器类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">compare</span> &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(node x, node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.a &gt; y.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node, vector&lt;node&gt;, compare&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; day &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; food[i].a &gt;&gt; food[i].b &gt;&gt; food[i].c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(food + <span class="number">1</span>, food + n + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="comment">//for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; food[i].a &lt;&lt; food[i].b &lt;&lt; food[i].c &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = day; i; i--) &#123; <span class="comment">// 时间倒流</span></span><br><span class="line"><span class="keyword">while</span> (food[idx].b &gt;= i) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(food[idx++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">ans += t.a;</span><br><span class="line"><span class="comment">//cout &lt;&lt; t.a &lt;&lt; &quot; &quot; &lt;&lt; t.b &lt;&lt; &quot; &quot; &lt;&lt; t.c &lt;&lt; &quot; &quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span> (t.c &gt; <span class="number">1</span>)q.<span class="built_in">push</span>((node) &#123;</span><br><span class="line">t.a, t.b, t.c - <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">day, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">food = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    food.append((b, a, c))</span><br><span class="line"></span><br><span class="line">food.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">q = []</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line">idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(day, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">while</span> idx &lt; n <span class="keyword">and</span> food[idx][<span class="number">0</span>] &gt;= i:</span><br><span class="line">        heapq.heappush(q, (food[idx][<span class="number">1</span>], food[idx][<span class="number">0</span>], food[idx][<span class="number">2</span>]))</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> q:</span><br><span class="line">        <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">        exit()</span><br><span class="line">    t = heapq.heappop(q)</span><br><span class="line">    ans += t[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> t[<span class="number">2</span>] &gt; <span class="number">1</span>:</span><br><span class="line">        heapq.heappush(q, (t[<span class="number">0</span>], t[<span class="number">1</span>], t[<span class="number">2</span>] - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h2 id="b3962-语言月赛-202404-游乐场---洛谷"><ahref="https://www.luogu.com.cn/problem/B3962">B3962 [语言月赛 202404]游乐场 - 洛谷</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n, x, ans, day, money;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">money += (x - day);</span><br><span class="line">money = <span class="built_in">min</span>(money, <span class="number">50LL</span>);</span><br><span class="line">day = x;</span><br><span class="line">ans += money / <span class="number">8</span>;</span><br><span class="line">money %= <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">money = <span class="number">0</span></span><br><span class="line">day = <span class="number">0</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    money += (x - day)</span><br><span class="line">    money = <span class="built_in">min</span>(money, <span class="number">50</span>)</span><br><span class="line">    day = x</span><br><span class="line">    ans += money // <span class="number">8</span></span><br><span class="line">    money %= <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h2 id="p8685-蓝桥杯-2019-省-a-外卖店优先级---洛谷"><ahref="https://www.luogu.com.cn/problem/P8685">P8685 [蓝桥杯 2019 省 A]外卖店优先级 - 洛谷</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="type">int</span> n, m, T;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">PII order[N];</span><br><span class="line"><span class="type">bool</span> hot[N];</span><br><span class="line"><span class="type">int</span> last[N], sorce[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;order[i].x, &amp;order[i].y);</span><br><span class="line"><span class="built_in">sort</span>(order, order + m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m;) &#123;</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j &lt; m &amp;&amp; order[j] == order[i]) j++;</span><br><span class="line"><span class="type">int</span> id = order[i].y, t = order[i].x, cnt = j - i;</span><br><span class="line">i = j;</span><br><span class="line">sorce[id] -= t - <span class="number">1</span> - last[id];</span><br><span class="line">last[id] = t;</span><br><span class="line"><span class="keyword">if</span> (sorce[id] &lt; <span class="number">0</span>) sorce[id] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (sorce[id] &lt;= <span class="number">3</span>) hot[id] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sorce[id] += cnt * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (sorce[id] &gt; <span class="number">5</span>) hot[id] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (last[i] &lt; T) &#123;</span><br><span class="line">sorce[i] -= T - last[i];</span><br><span class="line"><span class="keyword">if</span> (sorce[i] &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">hot[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (hot[i]) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">n, m, T = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">order = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    x, y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    order.append((x, y))</span><br><span class="line"></span><br><span class="line">order.sort()</span><br><span class="line">hot = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">last = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">sorce = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; m:</span><br><span class="line">    j = i</span><br><span class="line">    <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> order[j] == order[i]:</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="built_in">id</span> = order[i][<span class="number">1</span>]</span><br><span class="line">    t = order[i][<span class="number">0</span>]</span><br><span class="line">    cnt = j - i</span><br><span class="line">    i = j</span><br><span class="line">    sorce[<span class="built_in">id</span>] -= t - <span class="number">1</span> - last[<span class="built_in">id</span>]</span><br><span class="line">    last[<span class="built_in">id</span>] = t</span><br><span class="line">    <span class="keyword">if</span> sorce[<span class="built_in">id</span>] &lt; <span class="number">0</span>:</span><br><span class="line">        sorce[<span class="built_in">id</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> sorce[<span class="built_in">id</span>] &lt;= <span class="number">3</span>:</span><br><span class="line">        hot[<span class="built_in">id</span>] = <span class="literal">False</span></span><br><span class="line">    sorce[<span class="built_in">id</span>] += cnt * <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> sorce[<span class="built_in">id</span>] &gt; <span class="number">5</span>:</span><br><span class="line">        hot[<span class="built_in">id</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> last[i] &lt; T:</span><br><span class="line">        sorce[i] -= T - last[i]</span><br><span class="line">        <span class="keyword">if</span> sorce[i] &lt;= <span class="number">3</span>:</span><br><span class="line">            hot[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">ans = <span class="built_in">sum</span>(hot)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h2 id="p1601-ab-problem高精---洛谷"><ahref="https://www.luogu.com.cn/problem/P1601">P1601 A+B Problem（高精）- 洛谷</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; A, B, C;</span><br><span class="line">string a, b;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"><span class="type">int</span> i  = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; a.<span class="built_in">size</span>() || i &lt; b.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; a.<span class="built_in">size</span>())t += a[i];</span><br><span class="line"><span class="keyword">if</span> (i &lt; b.<span class="built_in">size</span>())t += b[i];</span><br><span class="line">c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">t = t / <span class="number">10</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">1</span>) c.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">C = <span class="built_in">add</span>(A, B);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">cout &lt;&lt; C[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure><h2 id="p10390-蓝桥杯-2024-省-a-因数计数---洛谷"><ahref="https://www.luogu.com.cn/problem/P10390">P10390 [蓝桥杯 2024 省 A]因数计数 - 洛谷</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int __int128 <span class="comment">// 使用 __int128 需要手写输入输出</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[N], x, mp[N], yinzi[N], beishu[N], ans;</span><br><span class="line"><span class="comment">// mp yinzi beishu 分别记录 x 的出现次数，因子个数，倍数个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="comment">// 非数字</span></span><br><span class="line"><span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数字</span></span><br><span class="line"><span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">res = res * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p * res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">10</span>)<span class="built_in">print</span>(x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>((x % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>);<span class="comment">// 输出要是字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)mp[<span class="built_in">read</span>()]++;</span><br><span class="line"><span class="comment">// 预处理每个数字的因子和倍数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mp[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt; N; j += i) &#123;</span><br><span class="line"><span class="keyword">if</span> (mp[j]) &#123;</span><br><span class="line"><span class="comment">// i 和 j 都存在</span></span><br><span class="line">beishu[i] += mp[j], yinzi[j] += mp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相同的值既是倍数也是因子（不能计自己）</span></span><br><span class="line">beishu[i] += mp[i] - <span class="number">1</span>, yinzi[i] += mp[i] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mp[i])ans += beishu[i] * mp[i];<span class="comment">// 原始数存在才能记</span></span><br><span class="line">&#125;</span><br><span class="line">ans *= (ans + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> ; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mp[i]) &#123;</span><br><span class="line">ans -= mp[i] * beishu[i] * beishu[i];</span><br><span class="line">ans -= mp[i] * yinzi[i] * yinzi[i];</span><br><span class="line">ans -= <span class="number">2</span> * (mp[i] * beishu[i] * yinzi[i]);</span><br><span class="line">ans += mp[i] * (mp[i] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">N = <span class="number">100000</span> + <span class="number">9</span></span><br><span class="line">n = read()</span><br><span class="line">a = [<span class="number">0</span>] * N</span><br><span class="line">mp = [<span class="number">0</span>] * N</span><br><span class="line">yinzi = [<span class="number">0</span>] * N</span><br><span class="line">beishu = [<span class="number">0</span>] * N</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    mp[read()] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">    <span class="keyword">if</span> mp[i]:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + i, N, i):</span><br><span class="line">            <span class="keyword">if</span> mp[j]:</span><br><span class="line">                beishu[i] += mp[j]</span><br><span class="line">                yinzi[j] += mp[i]</span><br><span class="line">        beishu[i] += mp[i] - <span class="number">1</span></span><br><span class="line">        yinzi[i] += mp[i] - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">    <span class="keyword">if</span> mp[i]:</span><br><span class="line">        ans += beishu[i] * mp[i]</span><br><span class="line"></span><br><span class="line">ans *= (ans + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">    <span class="keyword">if</span> mp[i]:</span><br><span class="line">        ans -= mp[i] * beishu[i] * beishu[i]</span><br><span class="line">        ans -= mp[i] * yinzi[i] * yinzi[i]</span><br><span class="line">        ans -= <span class="number">2</span> * (mp[i] * beishu[i] * yinzi[i])</span><br><span class="line">        ans += mp[i] * (mp[i] - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h2 id="p8647-蓝桥杯-2017-省-ab-分巧克力---洛谷"><ahref="https://www.luogu.com.cn/problem/P8647">P8647 [蓝桥杯 2017 省 AB]分巧克力 - 洛谷</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">PII ckl[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">ans += (ckl[i].x / h) * (ckl[i].y / h);</span><br><span class="line"><span class="keyword">if</span> (ans &gt;= k) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//符合</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; ckl[i].x &gt;&gt; ckl[i].y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>, r = N;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">h</span>):</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        ans += (ckl[i][<span class="number">0</span>] // h) * (ckl[i][<span class="number">1</span>] // h)</span><br><span class="line">        <span class="keyword">if</span> ans &gt;= k:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">ckl = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    x, y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    ckl.append((x, y))</span><br><span class="line"></span><br><span class="line">l, r = <span class="number">1</span>, <span class="number">100000</span> + <span class="number">9</span></span><br><span class="line"><span class="keyword">while</span> l &lt; r:</span><br><span class="line">    mid = (l + r + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> check(mid):</span><br><span class="line">        l = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure><h2 id="p10389-蓝桥杯-2024-省-a-成绩统计---洛谷"><ahref="https://www.luogu.com.cn/problem/P10389">P10389 [蓝桥杯 2024 省 A]成绩统计 - 洛谷</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n,k,t,ans = <span class="number">-1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+9</span>;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">tmp</span><span class="params">(len<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=len;i++)tmp[i] = a[i];</span><br><span class="line">    <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>()<span class="number">+1</span>,tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">s</span><span class="params">(len<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ps</span><span class="params">(len<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>]+tmp[i];</span><br><span class="line">        ps[i] = ps[i<span class="number">-1</span>]+tmp[i]*tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = k;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="type">double</span>)(ps[i]-ps[i-k]) - (<span class="type">double</span>)(s[i]-s[i-k])*(s[i]-s[i-k])/k &lt; (<span class="type">double</span>)t*k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    可以发现当检查了x名同学发现存在有k名的方差小于t时，自然检查[x+1,n]名通过都能成立</span></span><br><span class="line"><span class="comment">    因此这个条件是单调的，在[0,k-1]上一定不成立，在[k,n]上存在x使得条件成立</span></span><br><span class="line"><span class="comment">    故可以二分来求这个x</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> l = k,r = n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l = mid<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params"><span class="built_in">len</span></span>):</span><br><span class="line">    tmp = [<span class="number">0</span>] * (<span class="built_in">len</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span> + <span class="number">1</span>):</span><br><span class="line">        tmp[i] = a[i]</span><br><span class="line">    tmp.sort()</span><br><span class="line">    s = [<span class="number">0</span>] * (<span class="built_in">len</span> + <span class="number">1</span>)</span><br><span class="line">    ps = [<span class="number">0</span>] * (<span class="built_in">len</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span> + <span class="number">1</span>):</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + tmp[i]</span><br><span class="line">        ps[i] = ps[i - <span class="number">1</span>] + tmp[i] * tmp[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (ps[i] - ps[i - k]) - (s[i] - s[i - k]) * (s[i] - s[i - k]) / k &lt; t * k:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">n, k, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">a = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    a[i] = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">l, r = k, n</span><br><span class="line">ans = -<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> l &lt; r:</span><br><span class="line">    mid = (l + r) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> check(mid):</span><br><span class="line">        ans = mid</span><br><span class="line">        r = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计竞赛 </category>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计竞赛 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二讲-搜索与优化</title>
      <link href="/2025/03/09/%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2025/03/09/%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="作业链接">作业链接</h1><p><a href="https://www.luogu.com.cn/training/714047#problems">[蓝桥杯]第二讲：搜索与优化 - 题单 - 洛谷 | 计算机科学教育新生态</a></p><h1 id="ac-代码">AC 代码</h1><span id="more"></span><h2 id="b3642-二叉树的遍历---洛谷"><ahref="https://www.luogu.com.cn/problem/B3642">B3642 二叉树的遍历 -洛谷</a></h2><p>某序遍历，指中/根所在的位置：</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">&#125; node;</span><br><span class="line">node tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == <span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">node t = tr[u];</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">dfs</span>(k, t.l);</span><br><span class="line"><span class="built_in">dfs</span>(k, t.r);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">dfs</span>(k, t.l);</span><br><span class="line">cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">dfs</span>(k, t.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">dfs</span>(k, t.l);</span><br><span class="line"><span class="built_in">dfs</span>(k, t.r);</span><br><span class="line">cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; tr[i].l &gt;&gt; tr[i].r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p1219-usaco1.5-八皇后-checker-challenge---洛谷"><ahref="https://www.luogu.com.cn/problem/P1219">P1219 [USACO1.5] 八皇后Checker Challenge - 洛谷</a></h2><p>主对角线（左下右上）上的点满足：横纵坐标 x-y 为定值副对角线（左上右下）上的点满足：横纵坐标 x+y 为定值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, ans;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">bool</span> g[N][N], col[N], deg[N], udeg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == n) &#123;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[i][j]) cout &lt;&lt; j + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">ans++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!col[i] &amp;&amp; !deg[i + u] &amp;&amp; !udeg[i - u + n]) &#123;</span><br><span class="line">col[i] = deg[i + u] = udeg[i - u + n] = <span class="number">1</span>;</span><br><span class="line">g[u][i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">g[u][i] = <span class="number">0</span>;</span><br><span class="line">col[i] = deg[i + u] = udeg[i - u + n] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p8604-蓝桥杯-2013-国-c-危险系数---洛谷"><ahref="https://www.luogu.com.cn/problem/P8604">P8604 [蓝桥杯 2013 国 C]危险系数 - 洛谷</a></h2><h3 id="背景知识">背景知识</h3><p>在一个无向图中，如果删除某个顶点以及与该顶点相关联的所有边后，图的连通分量数增加，那么这个顶点就被称为割点。</p><h3 id="题意理解">题意理解</h3><p>在本题中，要求的关键点定义为：对于给定的两个顶点 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span>，如果删除某个顶点 <spanclass="math inline">\(z\)</span> 后，<spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 不再连通，那么 <spanclass="math inline">\(z\)</span> 就是关于 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的关键点。此处 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 不再连通等价于图的连通分量数增加，因此<span class="math inline">\(z\)</span> 满足割点的定义。本题退化为求<span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的点之间的割点数量。</p><h3 id="具体求法">具体求法</h3><p>如果一个点是两点间的割点，则两点之间的联通路径数应该均经过这个点，否则删去这个点后两个点依旧联通，与定义矛盾。因此我们只需要记录每一条通路使用了哪些点，则使用次数等于通路数的点就是点间割点。（图上割点需要用<a href="https://oi-wiki.org/graph/cut/">tarjan 算法</a>求解）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, a, b, u, v, ans, sum;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">9</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">sum++;<span class="comment">// 可联通的路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vis[i])cnt[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> t : g[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[t]) &#123;</span><br><span class="line">vis[t] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(t);</span><br><span class="line">vis[t] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">g[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">g[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(u);</span><br><span class="line"><span class="keyword">if</span> (sum) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum == cnt[i])ans++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans - <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p1443-马的遍历---洛谷"><ahref="https://www.luogu.com.cn/problem/P1443">P1443 马的遍历 -洛谷</a></h2><p>等权图最短路可以用 BFS 的洪泛策略求解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">403</span>;</span><br><span class="line"><span class="type">int</span> n, m, x, y, g[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m &amp;&amp; g[x][y] == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="comment">//下标从(1,1)开始</span></span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">g[x][y] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> tx = t.first + dx[i], ty = t.second + dy[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(tx, ty)) &#123;</span><br><span class="line">g[tx][ty] = g[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;tx, ty&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">g[i][j] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bfs</span>(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cout &lt;&lt; g[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p8662-蓝桥杯-2018-省-ab-全球变暖---洛谷"><ahref="https://www.luogu.com.cn/problem/P8662">P8662 [蓝桥杯 2018 省 AB]全球变暖 - 洛谷</a></h2><h3 id="题意理解-1">题意理解</h3><p>淹没的定义：陆地只要沿海就会被淹没。岛屿被完全淹没的定义：岛屿的所有陆地都被淹没。结合两个定义可以得到：岛屿的所有陆地都沿海则会被完全淹没。</p><h3 id="具体做法">具体做法</h3><p>求一块岛屿等价于用 bfs 找连通块，同时记录边界的陆地数 cnt和连通块总数 sum，如果 cnt ==sum，说明连通块的所有陆地都沿海，即这个岛屿会被完全淹没</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n, ans;</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 越界检查</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line">vis[x][y] = <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">sum++;</span><br><span class="line"><span class="type">bool</span> flg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">auto</span> tx = t.first + dx[i], ty = t.second + dy[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(tx, ty) &amp;&amp; !vis[tx][ty]) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[tx][ty] == <span class="string">&#x27;.&#x27;</span>)flg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vis[tx][ty] = <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;tx, ty&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flg) cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt == sum)ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">cin &gt;&gt; g[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; !vis[i][j]) &#123;</span><br><span class="line"><span class="comment">// 检查这个大陆是否会被淹没</span></span><br><span class="line"><span class="built_in">bfs</span>(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p8658-蓝桥杯-2017-国-a-填字母游戏---洛谷"><ahref="https://www.luogu.com.cn/problem/P8658">P8658 [蓝桥杯 2017 国 A]填字母游戏 - 洛谷</a></h2><p>记忆化已经得到结果的局面，避免重复计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, len;</span><br><span class="line">string s;</span><br><span class="line"><span class="comment">// mp 值的意义：0 未计算，1 小明败，2 平局，3 小明胜</span></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123; <span class="comment">// k = 0 表示小明在下棋，k = 1 表示 K 大师在下棋</span></span><br><span class="line"><span class="keyword">if</span> (mp[s])<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否还需要填字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)s.<span class="built_in">find</span>(<span class="string">&quot;LOL&quot;</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">// 当前的局面已经出现了 LOL，上一手已经结束了</span></span><br><span class="line">mp[s] = (k == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">3</span>); <span class="comment">// 如果当前是小明，则说明 K 大师之前已经赢了，因此结果是小明败</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)s.<span class="built_in">find</span>(<span class="string">&quot;*&quot;</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">// 不存在可以填的位置了，平局结束了</span></span><br><span class="line">mp[s] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tmp = (k == <span class="number">1</span> ? <span class="number">3</span> : <span class="number">1</span>); <span class="comment">// 谁在下认为谁输了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 可以填</span></span><br><span class="line"></span><br><span class="line">s[i] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span> - k); <span class="comment">// 交替手：0 变 1，1 变 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 小明在下</span></span><br><span class="line">tmp = <span class="built_in">max</span>(mp[s], tmp); <span class="comment">// 选最好的情况</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 反之，K 大师在下的话，选最坏情况</span></span><br><span class="line">tmp = <span class="built_in">min</span>(mp[s], tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最优解剪枝</span></span><br><span class="line"><span class="comment">如果现在是小明在下 k = 0 且胜利了 tmp = 3，则不用继续下了</span></span><br><span class="line"><span class="comment">如果现在是 K 大师在下 k = 1 且失败了 tmp = 1，判为小明胜利，也不用再下了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> ((k == <span class="number">0</span> &amp;&amp; tmp == <span class="number">3</span>) || (k == <span class="number">1</span> &amp;&amp; tmp == <span class="number">1</span>)) &#123;</span><br><span class="line">s[i] = <span class="string">&#x27;*&#x27;</span>;<span class="comment">// 恢复状态</span></span><br><span class="line">mp[s] = tmp;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s[i] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span> - k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">tmp = <span class="built_in">max</span>(mp[s], tmp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp = <span class="built_in">min</span>(mp[s], tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((k == <span class="number">0</span> &amp;&amp; tmp == <span class="number">3</span>) || (k == <span class="number">1</span> &amp;&amp; tmp == <span class="number">1</span>)) &#123;</span><br><span class="line">s[i] = <span class="string">&#x27;*&#x27;</span>;<span class="comment">// 恢复状态</span></span><br><span class="line">mp[s] = tmp;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">s[i] = <span class="string">&#x27;*&#x27;</span>; <span class="comment">// 状态复原</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mp[s] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">mp.<span class="built_in">clear</span>();</span><br><span class="line">len = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mp[s] - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p10386-蓝桥杯-2024-省-a-五子棋对弈---洛谷"><ahref="https://www.luogu.com.cn/problem/P10386">P10386 [蓝桥杯 2024 省 A]五子棋对弈 - 洛谷</a></h2><p>先按任意顺序模拟下棋过程，得到满盘局面后再判断是否合法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  直接先 dfs 得到所有下满棋盘的棋局（包括不合法的），因为题目说明不同落子得到的同一局面视为一种情况</span></span><br><span class="line"><span class="comment">  棋局的合法性判断：由于要求两人是交替放棋子的，且白子先走</span></span><br><span class="line"><span class="comment">  因此记白子个数为 x，黑子为 y，则 x-y == 1 为合法</span></span><br><span class="line"><span class="comment">  可以证明，当下满棋盘且两种颜色棋子满足这个数量关系时，必然有对应的合法落子顺序</span></span><br><span class="line"><span class="comment">  下面则检测是否有人胜利即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>, g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">bool</span> tmp;</span><br><span class="line"><span class="comment">// 判断是否轮流落子</span></span><br><span class="line"><span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[i][j] == <span class="number">1</span>)cnt1++;</span><br><span class="line"><span class="keyword">if</span> (g[i][j] == <span class="number">2</span>) cnt2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if (cnt1 + cnt2 != 25)cout &lt;&lt; cnt1 &lt;&lt; &quot; &quot; &lt;&lt; cnt2 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// 棋局不满足白棋先手且轮流落子，不合法</span></span><br><span class="line"><span class="keyword">if</span> (cnt1 - cnt2 != <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 横向判断</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">tmp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[i][j] != g[i][<span class="number">0</span>])tmp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 竖向判断</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">tmp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[j][i] != g[<span class="number">0</span>][i])tmp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 斜线判断</span></span><br><span class="line">tmp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[i][i] != g[<span class="number">0</span>][<span class="number">0</span>])tmp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 有人赢了，不是平局</span></span><br><span class="line">tmp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; <span class="number">5</span>; i--, j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[i][j] != g[<span class="number">4</span>][<span class="number">0</span>]) tmp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先按行下，下满了换下一行，行下满了检查</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="built_in">dfs</span>(x + <span class="number">1</span>, <span class="number">0</span>);<span class="comment">// 下一行</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">5</span>) &#123;<span class="comment">// 下满了</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>()) &#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g[x][y] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x, y + <span class="number">1</span>);</span><br><span class="line">g[x][y] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">g[x][y] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x, y + <span class="number">1</span>);</span><br><span class="line">g[x][y] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p9234-蓝桥杯-2023-省-a-买瓜---洛谷"><ahref="https://www.luogu.com.cn/problem/P9234">P9234 [蓝桥杯 2023 省 A]买瓜 - 洛谷</a></h2><p>排序优化、最优性剪枝、合法性剪枝、除法改乘法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">50</span>; <span class="comment">//ans维护最小劈瓜数  先设为一个大值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">50</span>];<span class="comment">//存瓜 原数组</span></span><br><span class="line"><span class="type">int</span> sum[<span class="number">50</span>];<span class="comment">//表示的是从第 i 个瓜到第 n 个瓜的总质量</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> i, <span class="type">int</span> cnt)</span> </span>&#123; <span class="comment">//总和，下标，劈瓜计数器</span></span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= ans)<span class="keyword">return</span>; <span class="comment">//剪枝</span></span><br><span class="line"><span class="keyword">if</span> (S == m) ans = <span class="built_in">min</span>(ans, cnt); <span class="comment">//如果相等，说明劈瓜劈够了，返回已经劈了几次瓜</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= n || S &gt;= m || S + sum[i] &lt; m) <span class="keyword">return</span> ; <span class="comment">//递归结束条件</span></span><br><span class="line"><span class="built_in">dfs</span>(S + a[i], i + <span class="number">1</span>, cnt); <span class="comment">//买一个瓜</span></span><br><span class="line"><span class="built_in">dfs</span>(S + a[i] / <span class="number">2</span>, i + <span class="number">1</span>, cnt + <span class="number">1</span>); <span class="comment">//买半个瓜，计数器+1</span></span><br><span class="line"><span class="built_in">dfs</span>(S, i + <span class="number">1</span>, cnt); <span class="comment">//不买当前瓜，跳到下一个瓜</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">m &lt;&lt;= <span class="number">1</span>; <span class="comment">//总质量也要*2才能保证结果不受影响</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i], a[i] &lt;&lt;= <span class="number">1</span>; <span class="comment">//为了防止劈瓜出现小数，将其左移一位*2倍</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, greater&lt;&gt;()); <span class="comment">//让质量大的在前面，争取最小劈瓜次数可以满足条件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有的瓜</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">sum[i] = sum[i + <span class="number">1</span>] + a[i]; <span class="comment">//当前瓜及其之后所有瓜的总质量=从1到下一个瓜的总质量+当前瓜的质量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ans == <span class="number">50</span>)cout &lt;&lt; <span class="number">-1</span>; <span class="comment">//最终 ans 仍然为初始值 50，则表示无法通过劈瓜的方式满足要求</span></span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计竞赛 </category>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计竞赛 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS 自学资源</title>
      <link href="/2025/03/06/CS%20%E8%87%AA%E5%AD%A6%E8%B5%84%E6%BA%90/"/>
      <url>/2025/03/06/CS%20%E8%87%AA%E5%AD%A6%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>算法学习资源导航</p><span id="more"></span><h1 id="竞赛向算法">竞赛向算法</h1><h2 id="系统化学习">系统化学习</h2><p><a href="https://www.acwing.com/">AcWing</a></p><p>提供语法基础课、算法基础课等系统化课程，适合竞赛入门与进阶，包含题目训练与视频讲解。</p><h2 id="题解与思路">题解与思路</h2><p><a href="https://www.cnblogs.com/dx123">董晓算法</a></p><p>针对竞赛题目分享详细题解，涵盖思路分析与代码实现，适合查漏补缺。</p><h1 id="就业向算法">就业向算法</h1><h2 id="学习路径">学习路径</h2><p><a href="https://programmercarl.com/">代码随想录</a></p><p>总结从零基础到算法面试的刷题顺序，配套详细题解与思路图，适合系统化复习。</p><h2 id="刷题平台">刷题平台</h2><p><a href="https://leetcode.cn/problemset/">LeetCode</a></p><p>经典面试算法题库，支持多语言，包含高频题与企业真题。</p><p><a href="https://www.nowcoder.com/">牛客网</a></p><p>提供算法题、企业笔试模拟、面试经验分享及求职信息。</p><h1 id="实战项目资源">实战项目资源</h1><h2 id="项目管理">项目管理</h2><p><a href="https://learngitbranching.js.org/?locale=zh_CN">git练习</a></p><p>学习 git 的使用方式</p><h2 id="项目教学">项目教学</h2><p><a href="https://www.codefather.cn/">鱼皮编程</a></p><p>从零开始带做完整项目，涵盖需求分析、架构设计到部署上线，适合积累实战经验。</p><h2 id="技术复现">技术复现</h2><p><a href="https://github.com/codecrafters-io/build-your-own-x">BuildYour Own X</a></p><p>通过复现常见技术，深入理解底层原理，提升技术深度。</p><h1 id="新兴技术">新兴技术</h1><h2 id="具身智能">具身智能</h2><p><ahref="https://github.com/TianxingChen/Embodied-AI-Guide">具身智能入门</a></p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析-第六章</title>
      <link href="/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
      <url>/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p><ahref="https://www.luogu.com.cn/record/161352997">推销员问题（简化版）</a></p><p><ahref="https://www.luogu.com.cn/record/159862249">售货员的难题</a></p><span id="more"></span><h1 id="货郎担问题tsp">货郎担问题（TSP）</h1><h2 id="题目大意">题目大意</h2><p>货郎担问题要求找到一条最短路径，让旅行者遍历所有城市后回到起点。针对不同的问题规模，分别采用不同的算法。</p><h2 id="解法描述">解法描述</h2><h3 id="朴素分支限界法bfs">朴素分支限界法（BFS）</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>借助队列实现广度优先搜索（BFS），每个节点存储当前路径和已访问的城市集合信息。在搜索过程中，维护一个<code>bestl</code>变量记录当前找到的最短路径长度，利用限界函数剪枝，即若当前节点路径长度加上到达下一个城市的成本大于<code>bestl</code>，则停止探索该节点，以此提高搜索效率。</p></li><li><p><strong>实现方式</strong></p><p>定义结构体<code>node</code>，包含当前路径长度<code>cl</code>、当前处理的城市编号<code>id</code>以及记录已访问城市的<code>bitset</code>。从起点城市1开始，创建初始节点并入队。在队列非空时，取出队首节点。若当前路径长度大于等于<code>bestl</code>，则进行剪枝；若已访问城市数量达到总城市数量（本题不要求形成环路），则更新<code>bestl</code>；否则，遍历所有城市，若城市未被访问、与当前城市可达且新路径长度小于<code>bestl</code>，则创建新节点并入队。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：理论时间复杂度为<spanclass="math inline">\(O(n!)\)</span> ，源于 BFS遍历排列树的特性，但实际执行中，由于限界条件的作用，时间复杂度会有所降低</li><li><strong>空间复杂度</strong>：空间复杂度为<spanclass="math inline">\(O(n!)\)</span>，因为在最坏情况下，队列需要存储整个解空间的排列树。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="type">int</span> bestl, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排列树的节点定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> cl; <span class="comment">// 当前走过的路径长度</span></span><br><span class="line"><span class="type">int</span> id; <span class="comment">// 处理的第几个城市</span></span><br><span class="line">bitset&lt;11&gt; visited; <span class="comment">// 集合记录已经访问过的城市</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="built_in">node</span>() &#123;&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">node</span>(<span class="type">int</span> cl_, <span class="type">int</span> id_) : <span class="built_in">cl</span>(cl_), <span class="built_in">id</span>(id_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 选用最小堆</span></span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"><span class="comment">// 创建一个节点，从该节点开始，因为1是固定位，其实是从1开始探索</span></span><br><span class="line"><span class="function">node <span class="title">temp</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">temp.visited.<span class="built_in">set</span>(<span class="number">1</span>);</span><br><span class="line">q.<span class="built_in">push</span>(temp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();<span class="comment">// 当前节点，也就是活节点</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span>  t = cur.id;</span><br><span class="line"><span class="comment">// 大于等于最优路径，没必要继续探索了，从下一个节点开始</span></span><br><span class="line"><span class="keyword">if</span> (cur.cl &gt;= bestl)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用bitset全1来判断是不是处理到最后一个城市</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)cur.visited.<span class="built_in">count</span>() == n) &#123;</span><br><span class="line"><span class="comment">//本题不用形成环路</span></span><br><span class="line">bestl = <span class="built_in">min</span>(bestl, cur.cl);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前节点开始探索</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>  j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line"><span class="comment">// 满足约束条件和限界条件</span></span><br><span class="line"><span class="keyword">if</span> (!cur.visited.<span class="built_in">test</span>(j) &amp;&amp; m[t][j] != INF &amp;&amp; cur.cl + m[t][j] &lt; bestl)</span><br><span class="line"><span class="comment">//未探索，可联通，可能更优</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; cur.cl &lt;&lt; endl;</span></span><br><span class="line">temp = <span class="built_in">node</span>(cur.cl + m[t][j], j);</span><br><span class="line">temp.visited = cur.visited;</span><br><span class="line">temp.visited.<span class="built_in">set</span>(j);</span><br><span class="line">q.<span class="built_in">push</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">bestl = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">cin &gt;&gt; temp;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="number">-1</span>)m[i][j] = INF;</span><br><span class="line"><span class="keyword">else</span> m[i][j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line">cout &lt;&lt; bestl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bellman-held-karp动态规划">Bellman-Held-Karp（动态规划）</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>利用状态压缩动态规划策略，将问题状态表示为当前访问的城市集合。其核心在于通过逐步添加新城市到当前集合，依据状态转移方程更新到达新城市的最小成本，最终从所有可能的回路中找出成本最小的路径。</p></li><li><p><strong>实现方式</strong></p><p>使用二维数组<code>dp[idx][t]</code>记录状态，<code>idx</code>是用二进制表示的城市集合，<code>t</code>表示当前到达的城市，<code>dp</code>的值代表在该状态下抵达城市<code>t</code>的消耗。先将<code>dp</code>数组初始化为极大值，设置<code>dp[1][0] = 0</code>，表示从起点0 出发到达自身成本为0。通过三层循环进行状态转移，外层循环遍历所有可能的城市集合（从 1 到<span class="math inline">\((1&lt;&lt;n)-1\)</span>），中层循环遍历集合内的城市<code>u</code>，内层循环遍历不在集合中的城市<code>v</code>，执行<code>dp[i|(1&lt;&lt;v)][v]=min(dp[i|(1&lt;&lt;v)][v], dp[i][u]+g[u][v])</code>更新状态。最后，通过<code>ans = min(ans, dp[(1&lt;&lt;n)-1][i]+g[i][0])</code>寻找最优边以构成最终回路，得出最小成本路径。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：时间复杂度为 <spanclass="math inline">\(O(n^2\times2^n)\)</span>，这是因为存在三层循环，其中两层与城市集合相关（复杂度为<spanclass="math inline">\(O(2^n)\)</span>），一层与城市数量相关（复杂度为<spanclass="math inline">\(O(n)\)</span> ）</li><li><strong>空间复杂度</strong>：空间复杂度是<spanclass="math inline">\(O(n\times2^n)\)</span>，主要用于存储动态规划表<code>dp</code>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//只有最多20个城市，可以采用状态压缩表示所有可能的回路，n个比特位，最多(2^n)-1种可能</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> g[N][N], n, dp[<span class="number">1</span> &lt;&lt; N][N], ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp[idx][t]的第一维是idx表示方案的编号，第二维是该方案的到达了点t，dp的值就是在这个方案下抵达城市t的消耗</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bellman_Held_Karp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line"><span class="comment">//进行(2^n)-1次循环，检查所有的可能，每一个i都代表的一个方案</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line"><span class="comment">//遍历所有点，找到那些已经在集合中的点</span></span><br><span class="line"><span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; u)) &#123;</span><br><span class="line"><span class="comment">//如果第u个点与上i是1，那说明这个点在本方案中，需要操作它</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span> ; v &lt; n; v++) &#123;</span><br><span class="line"><span class="comment">//以点u为当前集合的外延点，检查其余的点，看能不能加入集合</span></span><br><span class="line"><span class="keyword">if</span> (!(i &amp; (<span class="number">1</span> &lt;&lt; v))) &#123;</span><br><span class="line"><span class="comment">//如果v不在当前集合中，不会形成回路，可以用来更新dp数组</span></span><br><span class="line">dp[i | (<span class="number">1</span> &lt;&lt; v)][v] = <span class="built_in">min</span>(dp[i | (<span class="number">1</span> &lt;&lt; v)][v], dp[i][u] + g[u][v]);<span class="comment">//最小化消耗</span></span><br><span class="line"><span class="comment">//i|(1&lt;&lt;v)表示含有v的那个方案</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述代码形成了一个非回路解，下面需要寻找最优边来组合成最终回路</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; <span class="comment">//以这个值为第一维下标的dp表示经过了所有城市的解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">//检查最后一个dp中的所有值，以各个点为回环点，最小化答案</span></span><br><span class="line">ans = <span class="built_in">min</span>(ans, dp[t][i] + g[i][<span class="number">0</span>]); <span class="comment">//起点是0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);<span class="comment">//初始化为最大值</span></span><br><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//起点是0号城市，此时消耗为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">cin &gt;&gt; g[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Bellman_Held_Karp</span>();</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法设计与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析-第五章</title>
      <link href="/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/record/159902568">0/1背包问题（回溯法）</a></p><p><a href="https://www.luogu.com.cn/record/159080419">[NOIP 2002普及组] 选数</a></p><p><a href="https://www.luogu.com.cn/record/159082068">[USACO1.5] 八皇后Checker Challenge</a></p><span id="more"></span><h1 id="背包回溯法">0/1 背包（回溯法）</h1><h2 id="题目大意">题目大意</h2><p>给定一组物品，每个物品都有各自的重量和价值，同时给定一个背包的容量。要求在背包容量的限制下，选择物品装入背包，使得装入背包的物品总价值最大，且每个物品只能选择一次，最后输出这个最大总价值。</p><h2 id="解法描述">解法描述</h2><h3 id="回溯算法">回溯算法</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>回溯算法采用深度优先搜索策略，递归探索所有可能的物品选择组合，遍历解空间树。在搜索过程中，尝试将物品放入或不放入背包，构建可能的解。到达递归边界（考虑完所有物品）时，记录当前组合的总价值并与已记录的最大价值比较，若更大则更新最大价值。不断回溯尝试其他组合，直至找到最优解。</p></li><li><p><strong>实现方式</strong></p><ul><li><strong>核心函数</strong>：<code>dfs</code>函数接收当前物品索引<code>u</code>、背包已装物品总重量<code>sum</code>、总价值<code>val</code>和剩余物品总价值<code>rem</code>。若<code>u &gt; n</code>，比较并更新最大价值<code>ans</code>；若<code>sum &gt; m</code>或<code>rem + val &lt; ans</code>，直接返回。否则，递归考虑放入和不放入当前物品的情况。</li><li><strong>主函数流程</strong>：在<code>main</code>函数中，读入<code>n</code>、<code>m</code>和物品的重量、价值，计算总重量<code>tmp_w</code>和总价值<code>tmp_v</code>。若<code>tmp_w &lt;= m</code>，直接输出<code>tmp_v</code>；否则调用<code>dfs(1, 0, 0, tmp_v)</code>进行回溯搜索，最后输出最大价值<code>ans</code>。</li></ul></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：每个物品有放入或不放入两种选择，对于<code>n</code>个物品，时间复杂度为<spanclass="math inline">\(O(2^n)\)</span>，物品数量增加时，运行时间呈指数级增长。</li><li><strong>空间复杂度</strong>：主要取决于递归调用栈深度，最坏情况下深度为<code>n</code>，空间复杂度为<spanclass="math inline">\(O(n)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> n, m, v[N], w[N], tmp_w, tmp_v, ans;</span><br><span class="line"><span class="comment">//int f[N];</span></span><br><span class="line"><span class="comment">//int n, m, v[N], w[N], ans, tmp;</span></span><br><span class="line"><span class="comment">//bool st[N];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> sum, <span class="type">int</span> val, <span class="type">int</span> rem)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u &gt; n) &#123;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; val) &#123;</span><br><span class="line">ans = val;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; m) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (rem + val &lt; ans) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs</span>(u + <span class="number">1</span>, sum, val, rem - v[u]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(u + <span class="number">1</span>, sum + w[u], val + v[u], rem - v[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; w[i];</span><br><span class="line">tmp_w += w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; v[i];</span><br><span class="line">tmp_v += v[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;质量是&quot; &lt;&lt; w[i] &lt;&lt; &quot; &quot; &lt;&lt; &quot;价值是&quot; &lt;&lt; v[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">if</span> (tmp_w &lt;= m) &#123;</span><br><span class="line">cout &lt;&lt; tmp_v &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用dfs来做</span></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, tmp_v);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="noip-2002-普及组-选数">[NOIP 2002 普及组] 选数</h1><h2 id="题目大意-1">题目大意</h2><p>给定一个包含<spanclass="math inline">\(n\)</span>个整数的集合，从该集合中选取<spanclass="math inline">\(k\)</span>个元素，找出所有满足这<spanclass="math inline">\(k\)</span>个元素之和为素数的组合，最后输出满足条件的组合数量。</p><h2 id="解法描述-1">解法描述</h2><h3 id="回溯算法-1">回溯算法</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>回溯算法通过深度优先搜索的方式遍历所有可能的组合情况。它从空组合开始，逐步添加元素，在每一步决策中，尝试选择当前未被选择的元素加入组合，直到组合中元素个数达到<spanclass="math inline">\(k\)</span>个。然后检查该组合元素之和是否为素数，如果是，则将满足条件的组合数量加1。通过不断回溯，撤销之前的选择，尝试其他可能的组合，从而找出所有符合条件的组合。</p></li><li><p><strong>实现方式</strong></p><ul><li><strong>素数判断函数</strong>：<code>check(int x)</code>函数用于判断一个数是否为素数。通过从2 到<spanclass="math inline">\(\sqrt{x}\)</span>遍历，如果能找到一个数<spanclass="math inline">\(i\)</span>使得<spanclass="math inline">\(x\)</span>能被<spanclass="math inline">\(i\)</span>整除，则<spanclass="math inline">\(x\)</span>为合数，返回 0；否则<spanclass="math inline">\(x\)</span>为素数，返回 1。</li><li><strong>递归搜索函数</strong>：<code>dfs(int u, int sum, int start)</code>是核心递归函数。<code>u</code>表示当前已选择的元素个数，<code>sum</code>表示当前组合的元素之和，<code>start</code>表示从集合中的第<code>start</code>个元素开始考虑选择。当<code>u == k</code>时，说明已选择了<spanclass="math inline">\(k\)</span>个元素，调用<code>check(sum)</code>检查当前组合的和是否为素数，若是则<code>ans++</code>，然后返回。否则，从<code>start</code>开始，遍历集合中的元素，对于每个元素，递归调用<code>dfs(u + 1, sum + x[i], i + 1)</code>，即选择该元素加入组合，继续搜索下一个元素。</li></ul></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：算法的时间复杂度为<spanclass="math inline">\(O(n^k)\)</span>。因为在选择<spanclass="math inline">\(k\)</span>个元素的过程中，对于每一个位置的元素选择，都有<spanclass="math inline">\(n\)</span>种可能（在选择第一个元素时有<spanclass="math inline">\(n\)</span>种选择，选择第二个元素时有<spanclass="math inline">\(n -1\)</span>种选择，但由于从<code>start</code>开始，整体可近似看作每次都有<spanclass="math inline">\(n\)</span>种选择的复杂度），所以总的时间复杂度为<spanclass="math inline">\(n\)</span>的<spanclass="math inline">\(k\)</span>次方。随着<spanclass="math inline">\(n\)</span>和<spanclass="math inline">\(k\)</span>的增大，算法运行时间会快速增长。</li><li><strong>空间复杂度</strong>：空间复杂度主要由递归调用栈的深度决定。在最坏情况下，递归深度为<spanclass="math inline">\(k\)</span>（即选择<spanclass="math inline">\(k\)</span>个元素的过程），所以空间复杂度为<spanclass="math inline">\(O(k)\)</span>。此外，代码中还使用了一些辅助变量，如数组<code>x</code>和<code>st</code>，但它们的空间复杂度相对较小，不影响整体空间复杂度的量级。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  选数本质上是一个组合问题</span></span><br><span class="line"><span class="comment">  因此可以考虑让选取有顺序，避免构建成排列树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> n, k, ans;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> x[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//返回0说明是合数，返回1说明是素数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> sum, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == k) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(sum)) &#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">dfs</span>(u + <span class="number">1</span>, sum + x[i], i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; x[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="usaco1.5-八皇后-checker-challenge">[USACO1.5] 八皇后 CheckerChallenge</h1><h2 id="题目大意-2">题目大意</h2><p>在一个 <span class="math inline">\(n\times n\)</span> 的棋盘上放置<span class="math inline">\(n\)</span>个棋子，要求每行、每列有且仅有一个棋子，并且每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。需要找出所有满足条件的棋子放置方案。</p><h2 id="解法描述-2">解法描述</h2><h3 id="回溯算法-2">回溯算法</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>回溯算法是一种深度优先搜索策略，用于解决组合优化问题。对于八皇后问题，我们需要在棋盘上逐步尝试放置棋子，每放置一个棋子，都要检查其是否满足题目所规定的约束条件（每行、每列、每条对角线最多一个棋子）。如果满足条件，就继续在后续行放置棋子；如果不满足，就撤销当前放置，尝试其他位置。通过不断地尝试和回溯，遍历所有可能的放置方案，找出满足条件的解。</p></li><li><p><strong>实现方式</strong></p><ul><li><strong>分解问题</strong>：八皇后问题可以分解为逐行放置棋子的子问题。因为每行只能放置一个棋子，所以我们可以按行依次考虑，对于每一行，尝试在不同的列放置棋子。</li><li><strong>状态表示</strong>：为了判断某一列、某条对角线是否已经有棋子，我们需要合适的数据结构来记录状态。对于列，我们可以用一个一维数组<code>col</code> 来标记，<code>col[i]</code> 表示第 <code>i</code>列是否有棋子；对于对角线，由于从左上到右下的对角线可由<code>i + j</code> 唯一标识，从右上到左下的对角线可由<code>j - i + n</code> 唯一标识，所以分别用 <code>deg</code> 和<code>udeg</code> 数组来标记这两类对角线的状态。</li><li><strong>约束条件检查</strong>：在尝试放置一个棋子时，我们需要检查该位置所在的列、两条对角线是否已经有棋子。如果这些位置都没有棋子，说明该放置是合法的，可以继续递归处理下一行；否则，需要尝试其他列。</li><li><strong>回溯机制</strong>：当在某一行的所有列都尝试过，或者在某一步发现无法继续放置合法的棋子时，我们需要回溯到上一行，撤销上一行的放置，然后尝试该行的其他列。</li></ul></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：在最坏情况下，对于每一行都有 <spanclass="math inline">\(n\)</span> 种可能的放置位置，总共需要处理 <spanclass="math inline">\(n\)</span> 行，因此时间复杂度为 <spanclass="math inline">\(O(n^n)\)</span>。随着 <spanclass="math inline">\(n\)</span> 的增大，算法的运行时间会急剧增加。</li><li><strong>空间复杂度</strong>：主要的空间开销来自递归调用栈和辅助数组。递归调用栈的深度最大为<span class="math inline">\(n\)</span>，而辅助数组<code>col</code>、<code>deg</code>、<code>udeg</code> 和 <code>g</code>的空间复杂度均为 <spanclass="math inline">\(O(n^2)\)</span>，所以总的空间复杂度为 <spanclass="math inline">\(O(n^2)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, ans;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">bool</span> g[N][N], col[N], deg[N], udeg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == n) &#123;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[i][j]) cout &lt;&lt; j + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">ans++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!col[i] &amp;&amp; !deg[i + u] &amp;&amp; !udeg[i - u + n]) &#123;</span><br><span class="line">col[i] = deg[i + u] = udeg[i - u + n] = <span class="number">1</span>;</span><br><span class="line">g[u][i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">g[u][i] = <span class="number">0</span>;</span><br><span class="line">col[i] = deg[i + u] = udeg[i - u + n] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法设计与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析-第四章</title>
      <link href="/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p><ahref="https://www.luogu.com.cn/record/156146819">单源最短路径</a></p><p><ahref="https://www.luogu.com.cn/record/156152043">最小生成树</a></p><p><a href="https://www.luogu.com.cn/record/159640026">哈夫曼树</a></p><span id="more"></span><h1 id="单源最短路径">单源最短路径</h1><h2 id="题目大意">题目大意</h2><p>给定一个有向图，包含<span class="math inline">\(n\)</span>个点、<spanclass="math inline">\(m\)</span>条有向边以及一个出发点<spanclass="math inline">\(s\)</span>。图中每条边从点<spanclass="math inline">\(u\)</span>指向点<spanclass="math inline">\(v\)</span>，长度为<spanclass="math inline">\(w\)</span> 。要求计算并输出从出发点<spanclass="math inline">\(s\)</span>到图中其余<span class="math inline">\(n- 1\)</span>个点的最短路径长度，若无法从<spanclass="math inline">\(s\)</span>到达某个点，则输出<spanclass="math inline">\(2^{31}-1\)</span>（即 <code>INT_MAX</code>）。</p><h2 id="解法描述">解法描述</h2><h3 id="dijkstra-算法">Dijkstra 算法</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>采用贪心策略。从源点<spanclass="math inline">\(s\)</span>出发，维护一个距离源点最近的顶点集合。每次从集合外选取距离源点最近的顶点加入集合，利用该顶点更新其邻接顶点到源点的距离。由于边权非负，一旦某个顶点加入集合，其到源点的最短距离就确定下来，后续不会再改变。</p></li><li><p><strong>实现方式</strong></p><p>利用邻接表来存储图结构，通过 <code>add</code>函数添加边。定义<code>dist</code>数组记录源点到各顶点的最短距离，初始时将所有距离设为<code>INT_MAX</code>，<code>dist[s]</code>设为0；<code>st</code>数组用于标记顶点是否已确定最短路径。借助优先队列（小根堆）<code>heap</code>，按距离源点的距离从小到大存储顶点。在<code>dijkstra</code>函数中，持续从优先队列取出距离最小的顶点<code>u</code>，若 <code>u</code>已确定最短路径则跳过。遍历<code>u</code>的邻接顶点 <code>v</code>，若通过 <code>u</code>到<code>v</code>的距离小于当前 <code>dist[v]</code>，则更新<code>dist[v]</code>，并将 <code>v</code>加入优先队列。最后输出<code>dist</code>数组中的结果。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：使用邻接表和二叉堆实现时，每次从优先队列取出顶点的时间复杂度为<spanclass="math inline">\(O(\log n)\)</span>，总共处理<spanclass="math inline">\(n\)</span>个顶点，遍历边的时间复杂度为<spanclass="math inline">\(O(m)\)</span>，所以时间复杂度为<spanclass="math inline">\(O((n + m)\logn)\)</span>。若使用斐波那契堆，可优化到<spanclass="math inline">\(O(n\log n + m)\)</span>。</li><li><strong>空间复杂度</strong>：邻接表存储图需要<spanclass="math inline">\(O(n +m)\)</span>的空间；优先队列（二叉堆）存储顶点需要<spanclass="math inline">\(O(n)\)</span>空间；<code>dist</code>和<code>st</code>数组各需<spanclass="math inline">\(O(n)\)</span>空间。因此，总空间复杂度为<spanclass="math inline">\(O(n + m)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆优化dijkstra，邻接表存</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>, M = <span class="number">5e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">//s到所有点的最小距离</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">//防止重复入队</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INT_MAX;</span><br><span class="line">dist[s] = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap; <span class="comment">//小根堆</span></span><br><span class="line">heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;); <span class="comment">//入队</span></span><br><span class="line"><span class="keyword">while</span> (heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> index = t.second, distance = t.first;</span><br><span class="line"><span class="keyword">if</span> (st[index]) <span class="keyword">continue</span>; <span class="comment">//如果这个点已经检查过了，那就跳过</span></span><br><span class="line">st[index] = <span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[index]; i != <span class="number">-1</span>; i = ne[i]) &#123; <span class="comment">//检查出边</span></span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (dist[j] &gt; distance + w[i]) &#123;</span><br><span class="line">dist[j] = distance + w[i];</span><br><span class="line"><span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (dist[i] == INT_MAX ? INT_MAX : dist[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dijkstra</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa-算法">SPFA 算法</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>是 Bellman - Ford算法的队列优化版本。借助队列优化松弛操作，不断取出队首顶点，更新其邻接顶点的距离。若邻接顶点距离更新且未在队列中，则将其加入队列，直至队列为空。理论上边权可为负，但本题边权非负时也可使用。</p></li><li><p><strong>实现方式</strong></p><p>同样用邻接表存储图，<code>addedge</code>函数用于建图。<code>dis</code>数组记录源点到各顶点的距离，初始化为极大值，<code>dis[s]</code>设为0；<code>vis</code>数组标记顶点是否在队列中。在<code>spfa</code>函数里，将源点入队，在队列不为空时，取出队首顶点<code>u</code>，标记其出队，遍历 <code>u</code>的邻接顶点<code>v</code>，若通过 <code>u</code>到 <code>v</code>的距离小于当前<code>dis[v]</code>，则更新 <code>dis[v]</code>，若<code>v</code>不在队列中则将其入队并标记。最后输出<code>dis</code>数组中的结果。 3. <strong>复杂度分析</strong>：</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：最坏情况下，每个顶点入队<spanclass="math inline">\(n\)</span>次，每次入队遍历其出边，时间复杂度为<spanclass="math inline">\(O(nm)\)</span>。在随机图中，平均时间复杂度接近<spanclass="math inline">\(O(km)\)</span>（<spanclass="math inline">\(k\)</span>为常数且<span class="math inline">\(k\lt n\)</span> ）。本题边权为正，其时间复杂度比 Dijkstra 算法高。</li><li><strong>空间复杂度</strong>：邻接表存储图需要<spanclass="math inline">\(O(n + m)\)</span>空间；队列存储顶点最多需要<spanclass="math inline">\(O(n)\)</span>空间；<code>dis</code>和<code>vis</code>数组各需要<spanclass="math inline">\(O(n)\)</span>空间。所以总空间复杂度为<spanclass="math inline">\(O(n + m)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, s = <span class="number">1</span>, num_edge = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dis[maxn], vis[maxn], head[maxm];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line"><span class="type">int</span> next, to, dis;</span><br><span class="line">&#125; edge[maxm]; <span class="comment">//结构体表示静态邻接表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> dis)</span> </span>&#123; <span class="comment">//邻接表建图</span></span><br><span class="line">edge[++num_edge].next = head[from]; <span class="comment">//连式存储下一条出边</span></span><br><span class="line">edge[num_edge].to = to; <span class="comment">//当前节点编号</span></span><br><span class="line">edge[num_edge].dis = dis; <span class="comment">//本条边的距离</span></span><br><span class="line">head[from] = num_edge; <span class="comment">//记录下一次的出边情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//sqfa用队列，这里用了stl标准队列</span></span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">q.<span class="built_in">push</span>(s);</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">vis[s] = <span class="number">1</span>; <span class="comment">//第一个顶点入队，进行标记</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>(); <span class="comment">//取出队首</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">vis[u] = <span class="number">0</span>; <span class="comment">//出队标记</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = edge[i].next) &#123; <span class="comment">//邻接表的遍[历</span></span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span> (dis[v] &gt; dis[u] + edge[i].dis) &#123;</span><br><span class="line">dis[v] = dis[u] + edge[i].dis;</span><br><span class="line"><span class="keyword">if</span> (vis[v] == <span class="number">0</span>) &#123;</span><br><span class="line">vis[v] = <span class="number">1</span>; <span class="comment">//标记入队</span></span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (dis[i] == <span class="number">0x3f3f3f3f</span> ? INT_MAX : dis[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="type">int</span> f, g, w;</span><br><span class="line">cin &gt;&gt; f &gt;&gt; g &gt;&gt; w;</span><br><span class="line"><span class="built_in">addedge</span>(f, g, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spfa</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树">最小生成树</h1><h2 id="题目大意-1">题目大意</h2><p>给定一个图，图中包含顶点集合和边集合，每条边都有一个权重代表连接两个顶点的成本或距离。要求使用合适的算法找到该图的最小生成树，并计算最小生成树的总权重。</p><p>最小生成树（Minimum SpanningTree，MST）是在一个连通无向图中，由所有顶点和连接这些顶点的部分边构成的一棵树，这棵树满足以下两个关键特性：</p><ul><li>包含所有顶点：最小生成树包含图中的全部顶点。以城市交通图为例，每个城市是一个顶点，最小生成树必须涵盖所有城市，确保每个城市都能通过树中的边与其他城市相连通。</li><li>边权总和最小：在所有能够连接图中所有顶点的树中，最小生成树的边的权重之和是最小的。继续以城市交通图来说，边的权重可代表城市间建设道路的成本，最小生成树就表示用最低的总成本在所有城市间建立道路连接的方案，能避免不必要的高成本连接，达到资源的最优利用。</li></ul><h2 id="解法描述-1">解法描述</h2><h3 id="kruskal">Kruskal</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>采用贪心策略，先将图中所有边按权重从小到大排序。然后依次选取最短的边，若选取的边不会使已选边形成环，则将其加入最小生成树中，直到所有顶点都被包含在生成树中。</p></li><li><p><strong>实现方式</strong></p><p>首先读取图的顶点数 <span class="math inline">\(n\)</span>和边的权重信息，将有效边（权重不为-1）存储到数组<code>e</code>中。使用并查集数据结构（<code>find</code>函数和数组<code>p</code>）来检测加入某条边是否会产生环。对边数组<code>e</code>进行排序后，遍历每条边，判断边的两个端点是否在不同的集合（即不会形成环），若是，则合并这两个集合，并将边的权重累加到结果<code>ans</code>中。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：主要取决于边的排序，时间复杂度为 <spanclass="math inline">\(O(E log E)\)</span>，其中 <spanclass="math inline">\(E\)</span> 是边的数量。</li><li><strong>空间复杂度</strong>：使用邻接表存储图，空间复杂度是 <spanclass="math inline">\(O(V + E)\)</span>，<spanclass="math inline">\(V\)</span> 是顶点的数量。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>, MOD = <span class="number">100007</span>, M = <span class="number">6e7</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> n, g[N][N], idx, p[N], ans;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> a, b, w;</span><br><span class="line">&#125; edge;</span><br><span class="line">edge e[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(edge x, edge y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) &#123;</span><br><span class="line">p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">cin &gt;&gt; g[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[i][j] != - <span class="number">1</span>) e[idx++] = &#123;i, j, g[i][j]&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) p[i] = i;</span><br><span class="line"><span class="built_in">sort</span>(e, e + idx, cmp);</span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; idx; i++) &#123;</span></span><br><span class="line"><span class="comment">//auto t  = e[i];</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; t.a &lt;&lt; &quot; &quot; &lt;&lt; t.b &lt;&lt; &quot; &quot; &lt;&lt; t.w &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++) &#123;</span><br><span class="line"><span class="type">int</span> a, b, w;</span><br><span class="line">a = e[i].a, b = e[i].b, w = e[i].w;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(a) != <span class="built_in">find</span>(b)) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; find(a) &lt;&lt; &quot; &quot; &lt;&lt; find(b) &lt;&lt; endl;</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">ans = (ans + w) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prim">Prim</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>从任意一个顶点开始，逐步扩展生成树。每次选择连接已在生成树中的顶点和不在生成树中的顶点的最短边，直到所有顶点都被包含在生成树中。</p></li><li><p><strong>实现方式</strong></p><p>初始化距离数组 <code>dist</code>为无穷大，标记数组<code>st</code>为未访问。通过循环<code>n</code>次，每次在未访问的顶点中选择距离当前生成树最近的顶点<code>t</code>，将其距离累加到结果<code>ans</code>中，然后用该顶点更新其他顶点到生成树的距离，标记该顶点已访问。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：时间复杂度为 <spanclass="math inline">\(O(E + V log V)\)</span>，其中 <spanclass="math inline">\(V\)</span>是顶点的数量，这通常发生在使用优先队列（如二叉堆）选择最小边时。</li><li><strong>空间复杂度</strong>：使用邻接矩阵存储图，空间复杂度是 <spanclass="math inline">\(O(V^2)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//选点</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>, MOD = <span class="number">100007</span>;</span><br><span class="line"><span class="type">int</span> g[N][N], dist[N], st[N], ans; <span class="comment">//dist表示点到集合的距离，st表示点有没有被选过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//遍历n次，选择n个点</span></span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((!st[j]) &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) t = j; <span class="comment">//选择到集合最近的点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i) &#123; <span class="comment">//这里用于跳过第一次遍历，因为第一次还没有更新dist，距离都是无穷大。也不能提前选点来初始化dist，因为不知道哪些点是不可用的</span></span><br><span class="line">ans = (ans + dist[t]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if (i &amp;&amp; dist[t] == 0x3f3f3f3f) return INT_MAX; //如果在某一循环中，找不到可以到达的点，说明不连通</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="comment">//用找到的点来优化dist</span></span><br><span class="line">dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);<span class="comment">//t已经加入了集合，g[t][j]是从t到j的新距离</span></span><br><span class="line">&#125;</span><br><span class="line">st[t] = <span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) g[i][i] = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">-1</span>)g[i][j] = INT_MAX;</span><br><span class="line"><span class="keyword">else</span> g[i][j] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">prim</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈夫曼树">哈夫曼树</h1><h2 id="题目大意-2">题目大意</h2><p>题目给定 26 个小写字母 <code>a - z</code> 的非归一化概率以及一个由 26个小写字母组成的序列。需要根据这些字母的概率构建霍夫曼树，再使用该霍夫曼树对给定的字母序列进行压缩，最后计算压缩后该序列占用的总比特数。</p><h2 id="解法描述-2">解法描述</h2><h3 id="霍夫曼编码">霍夫曼编码</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>霍夫曼编码是一种用于数据压缩的贪心算法。其核心思想是根据字符出现的频率构建一棵二叉树，频率较低的字符离根节点较远，频率较高的字符离根节点较近。在构建树的过程中，每次选取频率最小的两个节点合并成一个新节点，新节点的频率为这两个节点频率之和，重复这个过程直到只剩下一个根节点。这样，每个字符的编码长度就由其在霍夫曼树中的深度决定，出现频率高的字符编码短，出现频率低的字符编码长，从而实现数据的压缩。</p></li><li><p><strong>实现方式</strong></p><ul><li><strong>输入处理</strong>：使用 <code>for</code> 循环读取 26个小写字母 <code>a - z</code>的非归一化概率，并将每个概率及其对应的索引（<code>idx</code> 从 0开始递增）以 <code>pair&lt;int, int&gt;</code> 的形式存入优先队列<code>huf</code> 中，优先队列按概率从小到大排序。</li><li><strong>构建霍夫曼树</strong>：当优先队列 <code>huf</code>中的元素数量大于 1 时，取出队首的两个元素 <code>t1</code> 和<code>t2</code>，将它们合并成一个新节点，新节点的概率为<code>t1.first + t2.first</code>，索引为 <code>idx</code>并递增。同时记录新节点的两个子节点为 <code>t1.second</code> 和<code>t2.second</code> 到 <code>son</code>数组中，再将新节点重新插入优先队列 <code>huf</code> 中。</li><li><strong>计算字符编码长度</strong>：定义深度优先搜索函数<code>dfs</code>，对于每个非叶子节点（索引大于等于26），递归地对其左右子节点调用 <code>dfs</code>函数；对于叶子节点（索引小于 26），对应字符的编码长度计数器<code>cnt[p]</code> 加 1。通过遍历所有节点调用 <code>dfs</code>函数，计算出每个字母的编码长度。</li></ul></li><li><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度</strong>：</p><p>构建优先队列的时间复杂度为 <span class="math inline">\(O(n logn)\)</span>，其中 <span class="math inline">\(n = 26\)</span>是字母的数量。构建霍夫曼树的过程中，每次从优先队列中取出两个元素并插入一个新元素，共进行<span class="math inline">\(n - 1\)</span>次操作，每次操作的时间复杂度为 <span class="math inline">\(O(logn)\)</span>，所以构建树的总时间复杂度为 <span class="math inline">\(O(nlogn)\)</span>。计算字符编码长度的深度优先搜索过程需要遍历所有节点，时间复杂度为<spanclass="math inline">\(O(n)\)</span>。计算总比特数需要遍历输入的字符串，设字符串长度为<span class="math inline">\(m\)</span>，时间复杂度为 <spanclass="math inline">\(O(m)\)</span>。综合起来，总的时间复杂度为 <spanclass="math inline">\(O(n log n + m)\)</span>。</p></li><li><p><strong>空间复杂度</strong>：</p><p>优先队列 <code>huf</code> 最多存储 <spanclass="math inline">\(n\)</span> 个元素，空间复杂度为 <spanclass="math inline">\(O(n)\)</span>。<code>son</code>数组用于存储霍夫曼树的节点关系，空间复杂度为 <spanclass="math inline">\(O(n)\)</span>。<code>cnt</code>数组用于存储每个字母的编码长度，空间复杂度为 <spanclass="math inline">\(O(n)\)</span>。因此，总的空间复杂度为 <spanclass="math inline">\(O(n)\)</span>。</p></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; <span class="comment">//占比，序号，编码长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, ans, idx;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">100007</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; huf;</span><br><span class="line">PII son[<span class="number">1000</span>];<span class="comment">//每个父节点对应两个子节点，对于26个字母，开1000个足够</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新节点对应的原始节点需要用dfs来取得，即依次向下深挖，找到原有节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt; <span class="number">26</span>) &#123; <span class="comment">//检查是否为叶节点</span></span><br><span class="line">cnt[p] ++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(son[p].first), <span class="built_in">dfs</span>(son[p].second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">huf.<span class="built_in">push</span>(&#123;x, &#123;idx++&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (huf.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">auto</span> t1 = huf.<span class="built_in">top</span>();</span><br><span class="line">huf.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">auto</span> t2 = huf.<span class="built_in">top</span>();</span><br><span class="line">huf.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//自下而上建立新节点</span></span><br><span class="line">son[idx] = &#123;t<span class="number">1.</span>second, t<span class="number">2.</span>second&#125;;</span><br><span class="line">huf.<span class="built_in">push</span>(&#123;t<span class="number">1.f</span>irst + t<span class="number">2.f</span>irst, idx++&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从非叶子节点开始，因为高度是h-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++) &#123;</span><br><span class="line"><span class="built_in">dfs</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dfs(idx - 1, 0);</span></span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item : s) &#123;</span><br><span class="line">ans = (ans + cnt[item - <span class="string">&#x27;a&#x27;</span>] - <span class="number">1</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; idx; i++) &#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; cnt[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法设计与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析-第三章</title>
      <link href="/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/record/151831788">0/1 背包</a></p><p><a href="https://www.luogu.com.cn/record/152948004">走砖路</a></p><p><a href="https://www.luogu.com.cn/record/152941077">编辑距离</a></p><span id="more"></span><h1 id="背包">0/1 背包</h1><h2 id="题目大意">题目大意</h2><p>给定 <code>n</code>种物品，每种物品都有对应的重量<code>w[i]</code>和价值 <code>v[i]</code>，同时有一个容量为<code>m</code>的背包。要求从这些物品中选择装入背包的物品，使得装入背包的物品总价值最大，并且每种物品只能选择一次，不能将物品分割装入背包。</p><p><em><del>背包问题中涉及数组下标，请注意数据范围对其的影响</del></em></p><h2 id="解法描述">解法描述</h2><h3 id="算法思想">算法思想</h3><p>动态规划的核心思想是把原问题分解为相互重叠的子问题，通过求解子问题并保存子问题的解，来避免重复计算，从而得到原问题的最优解。对于0/1 背包问题，定义状态 <code>dp[i][j]</code>表示前<code>i</code>个物品放入容量为<code>j</code>的背包中所能获得的最大价值。状态转移方程为：</p><p><span class="math display">\[dp[i][j] = \begin{cases} dp[i - 1][j] &amp; \text{if } j &lt; w[i] \\\max(dp[i - 1][j], dp[i - 1]j - w[i]] + v[i]) &amp; \text{if } j \geqw[i] \end{cases}\]</span></p><p>即当背包容量 <code>j</code>小于当前物品重量<code>w[i]</code>时，无法装入该物品，最大价值等于前<code>i - 1</code>个物品放入容量为<code>j</code>的背包的价值；当背包容量<code>j</code>大于等于当前物品重量<code>w[i]</code>时，比较不装入当前物品（价值为<code>dp[i - 1][j]</code>）和装入当前物品（价值为<code>dp[i - 1][j - w[i]] + v[i]</code>）的价值，取较大值作为<code>dp[i][j]</code>的值 。最终<code>dp[n][m]</code>就是问题的最优解。</p><h3 id="实现方式">实现方式</h3><ol type="1"><li><p><strong>朴素实现</strong></p><p>在代码中，先读取物品数量 <code>n</code>、背包容量<code>m</code>以及每个物品的重量 <code>w[i]</code>和价值<code>v[i]</code>。初始化一个二维数组<code>dp[n + 1][m + 1]</code>，并将其值初始化为0。然后通过两层嵌套循环，外层循环遍历物品（从 1 到<code>n</code>），内层循环遍历背包容量（从 0 到<code>m</code>）。在内层循环中，根据上述状态转移方程更新<code>dp[i][j]</code>的值。最后输出<code>dp[n][m]</code>，即能装入背包的物品的最大总价值。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素做法</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">     &#123;</span><br><span class="line">         dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">         <span class="keyword">if</span>(j&gt;=v[i]) dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j-v[i]]+w[i],dp[i][j]);<span class="comment">//当可以放下时，检测是否值得</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;dp[n][m];</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><p><strong>优化实现（滚动数组压缩）</strong></p><p>观察状态转移方程可以发现，<code>dp[i][j]</code>的值只与<code>dp[i - 1][j]</code>和<code>dp[i - 1][j - w[i]]</code>有关，即只与上一层的状态有关。因此，可以使用滚动数组将二维数组优化为一维数组。代码中定义一个一维数组<code>dp[m + 1]</code>，并初始化为 0。通过两层循环，外层循环遍历物品（从1 到 <code>n</code>），内层循环从背包容量<code>m</code>反向遍历到当前物品重量<code>v[i]</code>（因为正向遍历会导致同一个物品被多次计算）。在内层循环中，根据状态转移方程<code>dp[j] = max(dp[j], dp[j - v[i]] + w[i])</code>更新<code>dp[j]</code>的值。最后输出<code>dp[m]</code>，得到最大总价值。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反向遍历，滚动数组压缩</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--) &#123;</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[m];</span><br></pre></td></tr></table></figure><h3 id="复杂度分析">复杂度分析</h3><ol type="1"><li><strong>时间复杂度</strong>：无论是朴素实现还是优化实现，都存在两层嵌套循环，外层循环遍历物品数量<code>n</code>次，内层循环遍历背包容量<code>m</code>次。所以时间复杂度均为<spanclass="math inline">\(O(nm)\)</span>，其中<code>n</code>是物品的数量，<code>m</code>是背包的容量。</li><li><strong>空间复杂度</strong>：朴素实现中，使用了一个大小为<spanclass="math inline">\((n + 1) \times (m + 1)\)</span>的二维数组<code>dp</code>来保存中间状态，因此空间复杂度为<spanclass="math inline">\(O(nm)\)</span>。在优化实现（滚动数组压缩）中，使用了一个大小为<code>m + 1</code>的一维数组 <code>dp</code>，空间复杂度优化为<spanclass="math inline">\(O(m)\)</span>。</li></ol><h1 id="走砖路">走砖路</h1><h2 id="题目大意-1">题目大意</h2><p>有一条小路包含<code>n</code>块砖，初始位置在第一块砖，每次只能向前走一块砖或两块砖，需要求解恰好到达最后一块砖的不同走法数量。并且计算结果需要对给定的数<code>m</code>取模。</p><h2 id="解法描述-1">解法描述</h2><h3 id="算法思想-1">算法思想</h3><p>动态规划的核心在于将复杂问题分解为相互关联的子问题，并通过保存子问题的解来避免重复计算。对于走砖路问题，定义状态<code>dp[i]</code>表示到达第<code>i</code>块砖的方法数。因为每次可以走一步（从<code>i - 1</code>块砖走到 <code>i</code>块砖）或者走两步（从<code>i - 2</code>块砖走到 <code>i</code>块砖），所以到达第<code>i</code>块砖的走法数量就是到达<code>i - 1</code>块砖的走法数量与到达<code>i - 2</code>块砖的走法数量之和，即状态转移方程为<code>dp[i] = dp[i - 1] + dp[i - 2]</code>。考虑到计算过程中数值可能过大，所以每次计算结果都对<code>m</code>取模。通过逐步计算每个位置的走法数量，最终<code>dp[n]</code>就是到达最后一块砖的不同走法数量（需再对<code>m</code>取模）。</p><h3 id="实现方式-1">实现方式</h3><ol type="1"><li><p><strong>初始化</strong></p><p>在代码中，首先定义了一个常量数组<code>dp</code>用于存储到达每块砖的走法数量，其大小为<code>N</code>，还定义了取模值 <code>M</code>。读取输入的砖块数量<code>n</code>。然后初始化<code>dp</code>数组的前三项，<code>dp[1] = 0</code>（因为从起点（第 1块砖）出发到达第 1 块砖只有 0 种额外走法），<code>dp[2] = 1</code>（从第1 块砖走到第 2 块砖只有 1种走法，即走一步），<code>dp[3] = 2</code>（从第 1 块砖走到第 3块砖可以走一步到第 2 块砖再走一步，或者直接走两步，共 2种走法）。</p></li><li><p><strong>状态转移计算</strong></p><p>使用一个循环从 <code>i = 4</code>到<code>i = n</code>，根据状态转移方程<code>dp[i] = (dp[i - 1] + dp[i - 2]) % M</code>计算到达每一块砖的走法数量，并对结果取模。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000000</span>, M = <span class="number">100007</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) dp[i] = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n] % M;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1">复杂度分析</h3><ol type="1"><li><p><strong>时间复杂度</strong>：算法中存在一个从 <code>4</code>到<code>n</code>的循环，循环次数为<code>n - 3</code>次，每次循环内执行的操作时间复杂度为常数级。所以整体时间复杂度为<spanclass="math inline">\(O(n)\)</span>，其中<code>n</code>是砖块的数量。</p></li><li><p><strong>空间复杂度</strong>：算法使用了一个长度为<code>N</code>（这里 <code>N</code>被定义为 1000000 ）的数组<code>dp</code>来存储到达每块砖的走法数量，所以空间复杂度为<spanclass="math inline">\(O(n)\)</span>，其中<code>n</code>是砖块的数量。如果对空间复杂度进行优化，可以使用滚动数组，将空间复杂度降低到<spanclass="math inline">\(O(1)\)</span>，因为每次计算<code>dp[i]</code>只用到 <code>dp[i - 1]</code>和<code>dp[i - 2]</code>，只需要保存这两个状态即可。</p></li></ol><h1 id="编辑距离">编辑距离</h1><h2 id="题目大意-2">题目大意</h2><p>计算两个由小写字母 <code>a - z</code>组成的字符串之间的编辑距离。编辑距离的定义为：将一个字符串转化成另一个字符串最少需要进行的字符增加、删除、修改操作的次数。输入是一行，包含两个以空格分隔的字符串，输出是这两个字符串的编辑距离。</p><h2 id="解法描述-2">解法描述</h2><h3 id="算法思想-2">算法思想</h3><p>动态规划的核心在于将原问题分解为一系列相互关联的子问题，并且保存这些子问题的解，避免重复计算。对于编辑距离问题，我们定义一个二维数组<code>dp</code>，其中 <code>dp[i][j]</code> 表示字符串 <code>s1</code>的前 <code>i</code> 个字符和字符串 <code>s2</code> 的前 <code>j</code>个字符之间的编辑距离。通过求解一系列子问题，最终得到原问题的解。</p><h3 id="实现方式-2">实现方式</h3><ol type="1"><li><strong>输入处理</strong></li></ol><ul><li>使用 <code>cin &gt;&gt; s1 + 1 &gt;&gt; s2 + 1</code>读取两个字符串，这里 <code>s1 + 1</code> 和 <code>s2 + 1</code>是为了让字符串从下标 1 开始存储，方便后续处理。</li><li>通过循环计算两个字符串的长度 <code>n1</code> 和<code>n2</code>。</li></ul><ol start="2" type="1"><li><strong>初始化</strong>：使用<code>memset(dp, 0x3f3f3f3f, sizeof dp)</code> 将 <code>dp</code>数组初始化为一个较大的值（近似无穷大），表示初始状态下还未找到有效的编辑距离。</li></ol><ul><li>初始化边界条件：<ul><li>当 <code>s2</code> 为空字符串时，将 <code>s1</code> 的前<code>i</code> 个字符转换为 <code>s2</code> （空字符串）需要删除<code>i</code> 个字符，所以 <code>dp[i][0] = i</code>，其中<code>i</code> 从 0 到 <code>n1 - 1</code>。</li><li>当 <code>s1</code> 为空字符串时，将 <code>s1</code> 转换为<code>s2</code> 的前 <code>i</code> 个字符需要添加 <code>i</code>个字符，所以 <code>dp[0][i] = i</code>，其中 <code>i</code> 从 0 到<code>n2 - 1</code>。</li></ul></li></ul><ol start="3" type="1"><li><strong>状态转移</strong>：设字符串 <code>s1</code> 的长度为<code>n1</code>，字符串 <code>s2</code> 的长度为 <code>n2</code>，对于<code>1 ≤ i ≤ n1</code> 和<code>1 ≤ j ≤ n2</code>，状态转移分为以下两种情况：</li></ol><ul><li><p>当 <code>s1[i] == s2[j]</code>时，当前字符不需要进行修改操作。此时 <code>dp[i][j]</code>可以从以下三种情况转移而来：</p><ul><li>情况一：不进行任何操作，直接继承 <code>s1</code> 的前<code>i - 1</code> 个字符和 <code>s2</code> 的前 <code>j - 1</code>个字符的编辑距离，即 <code>dp[i - 1][j - 1]</code>。</li><li>情况二：删除 <code>s1</code> 的第 <code>i</code>个字符，那么编辑距离为 <code>dp[i - 1][j] + 1</code>。</li><li>情况三：添加 <code>s2</code> 的第 <code>j</code> 个字符到<code>s1</code> 中，编辑距离为 <code>dp[i][j - 1] + 1</code>。</li></ul><p>我们取这三种情况的最小值作为 <code>dp[i][j]</code>的值，用公式表示为： <span class="math display">\[ dp[i][j] =\min\left\{dp[i - 1][j - 1], dp[i - 1][j] + 1, dp[i][j - 1] + 1\right\}\]</span></p></li><li><p>当 <code>s1[i] != s2[j]</code>时，需要进行一次修改操作。同样，<code>dp[i][j]</code>也可以从以下三种情况转移而来：</p><ul><li>情况一：将 <code>s1</code> 的第 <code>i</code> 个字符修改为<code>s2</code> 的第 <code>j</code> 个字符，编辑距离为<code>dp[i - 1][j - 1] + 1</code>。</li><li>情况二：删除 <code>s1</code> 的第 <code>i</code> 个字符，编辑距离为<code>dp[i - 1][j] + 1</code>。</li><li>情况三：添加 <code>s2</code> 的第 <code>j</code> 个字符到<code>s1</code> 中，编辑距离为 <code>dp[i][j - 1] + 1</code>。</li></ul><p>我们取这三种情况的最小值作为 <code>dp[i][j]</code>的值，用公式表示为： <span class="math display">\[ dp[i][j] =\min\left\{dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] +1\right\} \]</span></p></li></ul><h3 id="复杂度分析-2">复杂度分析</h3><ul><li><strong>时间复杂度</strong>：代码中有两层嵌套循环，外层循环遍历<code>s1</code> 的长度 <code>n1</code>，内层循环遍历 <code>s2</code>的长度 <code>n2</code>，因此时间复杂度为 <spanclass="math inline">\(O(n1 * n2)\)</span>。</li><li><strong>空间复杂度</strong>：使用了一个二维数组 <code>dp</code>来保存子问题的解，数组大小为 <code>N * N</code>，因此空间复杂度为 <spanclass="math inline">\(O(N^2)\)</span>，在本题中 <code>N</code>为最大字符串长度。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">1e3</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">char</span> s1[N], s2[N];</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; s1 + <span class="number">1</span> &gt;&gt; s2 + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s1[n1] != <span class="string">&#x27;\0&#x27;</span>) n1++;</span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s2[n2] != <span class="string">&#x27;\0&#x27;</span>) n2++;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; n1 &lt;&lt; &quot; &quot; &lt;&lt; n2 &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[j]) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                tmp = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, tmp);</span><br><span class="line">                tmp = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, tmp);</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(tmp, dp[i][j]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> tmp = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                tmp = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, tmp);</span><br><span class="line">                tmp = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, tmp);</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(tmp, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//for (int x = 0; x &lt; n1; x++) &#123;</span></span><br><span class="line">            <span class="comment">//for (int y = 0; y &lt; n2; y++) &#123;</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; dp[x][y] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">//puts(&quot;&quot;);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">//puts(&quot;&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n1][n2];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法设计与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析-第二章</title>
      <link href="/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p><ahref="https://www.luogu.com.cn/record/150679164">二分检索（分治法）</a></p><p><ahref="https://www.luogu.com.cn/record/150682327">矩阵乘法（分治法）</a></p><p><a href="https://www.luogu.com.cn/record/150680931">第 K小元素（分治法）</a></p><span id="more"></span><h1 id="二分检索分治法">二分检索（分治法）</h1><h2 id="题目大意">题目大意</h2><p>给定一个大小为 <span class="math inline">\(n\)</span> 的递增整数序列<span class="math inline">\(L\)</span>，使用二分查找法查找任意元素 <spanclass="math inline">\(x\)</span> 在序列中的位置 <spanclass="math inline">\(k\)</span>（即序列中的第几个元素），若元素不存在则返回-1。要求编写程序实现二分查找算法，并对其时间复杂度和空间复杂度进行分析，同时通过实验评估算法性能。</p><h2 id="解法描述">解法描述</h2><ol type="1"><li><p><strong>算法思想</strong></p><p>二分查找算法基于分治思想，适用于有序数组。其核心是将待查找区间不断二分，通过比较中间元素与目标元素的大小关系，确定目标元素可能存在的新区间，逐步缩小查找范围，直到找到目标元素或确定其不存在。</p></li><li><p><strong>实现方式</strong></p><p>程序中，先接收输入的序列大小 <spanclass="math inline">\(n\)</span>、序列 <spanclass="math inline">\(L\)</span> 以及要查找的元素 <spanclass="math inline">\(x\)</span>。初始化左右指针 <code>left = -1</code>和 <code>right = n</code>，在 <code>left &lt; right</code>的循环中，计算中间元素下标 <code>mid = (left + right) / 2</code>。若<code>a[mid] &gt;= x</code>，说明目标元素可能在左半部分，更新<code>right = mid</code>；若<code>a[mid] &lt; x</code>，则目标元素在右半部分，更新<code>left = mid + 1</code>。循环结束后，判断 <code>a[left]</code>是否等于目标元素 <code>x</code>，若相等则返回<code>left</code>，否则返回 -1。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：每次迭代都将待查找区间减半，假设序列大小为<span class="math inline">\(n\)</span>，最多需要进行 <spanclass="math inline">\(\log n\)</span>次迭代就能找到目标元素或确定其不存在，所以时间复杂度为 <spanclass="math inline">\(O(\log n)\)</span>。</li><li><strong>空间复杂度</strong>：算法执行过程中，除输入数据外，仅使用了几个辅助变量（如<code>left</code>、<code>right</code>、<code>mid</code>），这些变量占用的空间不随输入规模<span class="math inline">\(n\)</span> 的变化而变化，因此空间复杂度为<span class="math inline">\(O(1)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100009</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (a[l] == x ? l : <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵乘法分治法">矩阵乘法（分治法）</h1><h2 id="题目大意-1">题目大意</h2><p>给定两个矩阵 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span>，使用分治法实现矩阵乘法，并与朴素矩阵乘法算法进行比较。要求编写程序实现相关算法，分析算法的正确性、时间复杂度和空间复杂度，并通过实验测试评估算法性能。</p><h2 id="解法描述-1">解法描述</h2><ol type="1"><li><p><strong>算法思想</strong></p><ul><li><strong>朴素矩阵乘法</strong>：根据矩阵乘法定义，结果矩阵 <spanclass="math inline">\(C\)</span> 的每个元素 <spanclass="math inline">\(C_{ij}\)</span> 是矩阵 <spanclass="math inline">\(A\)</span> 的第 <spanclass="math inline">\(i\)</span> 行与矩阵 <spanclass="math inline">\(B\)</span> 的第 <spanclass="math inline">\(j\)</span>列对应元素乘积之和。通过三重循环遍历实现，时间复杂度较高，为 <spanclass="math inline">\(O(n^3)\)</span>。</li><li><strong>Strassen分治算法</strong>：基于分治策略，将大矩阵乘法问题分解为多个小规模子矩阵乘法问题。把输入矩阵<span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span>各划分为四个大小相等的子矩阵，通过特定的加减法和 7次递归的子矩阵乘法，再进行线性组合得到结果矩阵。这种方法减少了乘法次数，理论上时间复杂度为<span class="math inline">\(O(n^{2.7})\)</span>。</li></ul></li><li><p><strong>实现方式</strong></p><ul><li><strong>矩阵表示</strong>：使用二维向量<code>vector&lt;vector&lt;int&gt;&gt;</code>表示矩阵，方便对矩阵元素进行访问和操作。</li><li><strong>辅助函数</strong>：实现矩阵加法 <code>matrixAdd</code>和减法 <code>matrixSubtract</code> 函数，用于 Strassen算法中矩阵的加减运算；实现朴素矩阵乘法 <code>matrixMultiply</code>函数，通过三重循环计算结果矩阵。</li><li><strong>Strassen 算法实现</strong>：在 <code>strassen</code>函数中，先处理矩阵规模为 2的基本情况，直接调用朴素矩阵乘法。对于更大规模矩阵，将其分割为子矩阵，计算中间矩阵<spanclass="math inline">\(S_i\)</span> ，递归计算 7 个乘积矩阵 <spanclass="math inline">\(M_i\)</span> ，最后通过线性组合得到结果矩阵 <spanclass="math inline">\(C\)</span> 的四个子矩阵 <spanclass="math inline">\(C_{11}\)</span>、<spanclass="math inline">\(C_{12}\)</span>、<spanclass="math inline">\(C_{21}\)</span>、<spanclass="math inline">\(C_{22}\)</span>，并组合成最终结果矩阵。</li></ul></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>朴素矩阵乘法</strong>：<ul><li><strong>时间复杂度</strong>：有三层嵌套循环，每层循环次数都为矩阵大小<span class="math inline">\(n\)</span>，所以时间复杂度为 <spanclass="math inline">\(O(n^3)\)</span>。</li><li><strong>空间复杂度</strong>：仅使用一个结果矩阵存储最终乘积，空间复杂度为<span class="math inline">\(O(n^2)\)</span>。</li></ul></li><li><strong>Strassen 分治算法</strong>：<ul><li><strong>时间复杂度</strong>：通过减少乘法次数，理论时间复杂度降为<spanclass="math inline">\(O(n^{2.7})\)</span>，但由于常数项较大，在小规模矩阵时效率可能不如朴素算法。</li><li><strong>空间复杂度</strong>：与朴素矩阵乘法相同，都需要一个结果矩阵存储最终结果，空间复杂度为<span class="math inline">\(O(n^2)\)</span>。</li></ul></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, N;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; VVI;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="comment">////将矩阵扩展为2的倍数</span></span><br><span class="line"><span class="comment">//VVI extendMatrix(const VVI&amp; A) &#123;</span></span><br><span class="line"><span class="comment">//    int originalSize = A.size();</span></span><br><span class="line"><span class="comment">//    int newSize = (originalSize % 2 == 0 ? originalSize : originalSize + 1);</span></span><br><span class="line"><span class="comment">//    VVI extendedMatrix(newSize, VI(newSize, 0));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; originalSize; ++i)</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; originalSize; ++j)</span></span><br><span class="line"><span class="comment">//            extendedMatrix[i][j] = A[i][j];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    return extendedMatrix;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 截取矩阵大小到原始大小</span></span><br><span class="line"><span class="comment">//vector&lt;vector&lt;int&gt;&gt; truncateMatrix(const vector&lt;vector&lt;int&gt;&gt;&amp; A, int originalSize) &#123;</span></span><br><span class="line"><span class="comment">//    vector&lt;vector&lt;int&gt;&gt; truncatedMatrix(originalSize, vector&lt;int&gt;(originalSize, 0));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; originalSize; ++i)</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; originalSize; ++j)</span></span><br><span class="line"><span class="comment">//            truncatedMatrix[i][j] = A[i][j];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    return truncatedMatrix;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵加法A+B</span></span><br><span class="line"><span class="function">VVI <span class="title">matrixAdd</span><span class="params">(<span class="type">const</span> VVI&amp; A, <span class="type">const</span> VVI&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">VVI <span class="title">result</span><span class="params">(n, VI(n, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            result[i][j] = A[i][j] + B[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//矩阵减法A-B</span></span><br><span class="line"><span class="function">VVI <span class="title">matrixSubtract</span><span class="params">( <span class="type">const</span> VVI&amp; A, <span class="type">const</span> VVI&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">VVI <span class="title">result</span><span class="params">(n, VI(n, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            result[i][j] = A[i][j] - B[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//矩阵乘法</span></span><br><span class="line"><span class="function">VVI <span class="title">matrixMultiply</span><span class="params">(<span class="type">const</span> VVI&amp; A, <span class="type">const</span> VVI&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">VVI <span class="title">result</span><span class="params">(n, VI(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span> ; k &lt; n; k++)</span><br><span class="line">                result[i][j] += A[i][k] * B[k][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Strassen算法</span></span><br><span class="line"><span class="function">VVI <span class="title">strassen</span><span class="params">(VVI A, VVI B)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">VVI <span class="title">result</span><span class="params">(n, VI(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        result = <span class="built_in">matrixMultiply</span>(A, B);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将矩阵分割成四个子矩阵</span></span><br><span class="line">    <span class="type">int</span> newSize = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">VVI <span class="title">A11</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">A12</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">A21</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">A22</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">VVI <span class="title">B11</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">B12</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">B21</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">B22</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原始矩阵拆分成四个子矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; newSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; newSize; ++j) &#123;</span><br><span class="line">            A11[i][j] = A[i][j];</span><br><span class="line">            A12[i][j] = A[i][j + newSize];</span><br><span class="line">            A21[i][j] = A[i + newSize][j];</span><br><span class="line">            A22[i][j] = A[i + newSize][j + newSize];</span><br><span class="line"></span><br><span class="line">            B11[i][j] = B[i][j];</span><br><span class="line">            B12[i][j] = B[i][j + newSize];</span><br><span class="line">            B21[i][j] = B[i + newSize][j];</span><br><span class="line">            B22[i][j] = B[i + newSize][j + newSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">VVI <span class="title">S1</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S2</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S3</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S4</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S5</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S6</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S7</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S8</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S9</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S10</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用加减法计算这10个过程矩阵</span></span><br><span class="line"></span><br><span class="line">    S1 = <span class="built_in">matrixSubtract</span>(A12, A22);</span><br><span class="line">    S2 = <span class="built_in">matrixAdd</span>( B21, B22);</span><br><span class="line">    S3 = <span class="built_in">matrixAdd</span>( A11, A22);</span><br><span class="line">    S4 = <span class="built_in">matrixAdd</span>(B11, B22);</span><br><span class="line">    S5 = <span class="built_in">matrixSubtract</span>( A11, A21);</span><br><span class="line">    S6 = <span class="built_in">matrixAdd</span>( B11, B12);</span><br><span class="line">    S7 = <span class="built_in">matrixAdd</span>(A11, A12);</span><br><span class="line">    S8 = <span class="built_in">matrixSubtract</span>( B12, B22);</span><br><span class="line">    S9 = <span class="built_in">matrixSubtract</span>( B21, B11);</span><br><span class="line">    S10 = <span class="built_in">matrixAdd</span>(A21, A22);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算7次乘法</span></span><br><span class="line"></span><br><span class="line">    VVI M1 = <span class="built_in">strassen</span>(S1, S2);</span><br><span class="line">    VVI M2 = <span class="built_in">strassen</span>(S3, S4);</span><br><span class="line">    VVI M3 = <span class="built_in">strassen</span>(S5, S6);</span><br><span class="line">    VVI M4 = <span class="built_in">strassen</span>(S7, B22);</span><br><span class="line">    VVI M5 = <span class="built_in">strassen</span>(A11, S8);</span><br><span class="line">    VVI M6 = <span class="built_in">strassen</span>(A22, S9);</span><br><span class="line">    VVI M7 = <span class="built_in">strassen</span>(S10, B11);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线性组合乘积矩阵</span></span><br><span class="line">    VVI C11 = <span class="built_in">matrixAdd</span>(M1, M2);</span><br><span class="line">    C11 = <span class="built_in">matrixSubtract</span>(C11, M4);</span><br><span class="line">    C11 = <span class="built_in">matrixAdd</span>(C11, M6);</span><br><span class="line"></span><br><span class="line">    VVI C12 = <span class="built_in">matrixAdd</span>(M4, M5);</span><br><span class="line">    VVI C21 = <span class="built_in">matrixAdd</span>(M6, M7);</span><br><span class="line"></span><br><span class="line">    VVI C22 = <span class="built_in">matrixSubtract</span>(M2, M3);</span><br><span class="line">    C22 = <span class="built_in">matrixAdd</span>(C22, M5);</span><br><span class="line">    C22 = <span class="built_in">matrixSubtract</span>(C22, M7);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建结果矩阵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; newSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; newSize; ++j) &#123;</span><br><span class="line">            result[i][j] = C11[i][j];</span><br><span class="line">            result[i][j + newSize] = C12[i][j];</span><br><span class="line">            result[i + newSize][j] = C21[i][j];</span><br><span class="line">            result[i + newSize][j + newSize] = C22[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow_2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>) <span class="keyword">return</span> n;<span class="comment">//等于零说明只有一个1，即最高位为1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ((n &amp; (n - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//将n转化2的倍数</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        N = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        N = <span class="built_in">pow_2</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成1000阶方阵 a 和 b</span></span><br><span class="line">    <span class="function">VVI <span class="title">a</span><span class="params">(N, VI(N))</span>, <span class="title">b</span><span class="params">(N, VI(N))</span>, <span class="title">c</span><span class="params">(N, VI(N))</span>, <span class="title">result</span><span class="params">(N, VI(N))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            a[i][j] = <span class="built_in">rand</span>() % <span class="number">100</span>; <span class="comment">// 生成范围为 0 到 99 的随机数</span></span><br><span class="line">            b[i][j] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line"><span class="comment">//            if (i == N || j == N) a[i][j] = b[i][j] = 0;//补零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    //初始化二维向量</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">//            cin &gt;&gt; a[i][j];</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">//            cin &gt;&gt; b[i][j];</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    cout &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        puts(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; b[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        puts(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> <span class="type">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="comment">//朴素乘法，时间复杂度为O(n^3)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                c[i][j] += a[i][k] * b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    puts(&quot;&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; c[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     Strassen算法：</span></span><br><span class="line"><span class="comment">      对任意两个2*n阶的矩阵a和b相乘（不足偶数阶的矩阵可以补零扩展），可以将它们各划分为4个小矩阵</span></span><br><span class="line"><span class="comment">      然后将这8个矩阵使用特定的算法求7次乘积，最后将7个临时矩阵M通过加减组合得到最后的第8个结果矩阵</span></span><br><span class="line"><span class="comment">      再将这8个结果矩阵组合为目标矩阵c。</span></span><br><span class="line"><span class="comment">      优点：只有7次乘法，时间复杂度降低为O(n^2.7)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">clock_t</span> <span class="type">tmp_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">    result = <span class="built_in">strassen</span>(a, b);</span><br><span class="line">    <span class="type">clock_t</span> <span class="type">end_t</span> = <span class="built_in">clock</span>();</span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">////            if (i &gt; n - 1 || j &gt; n - 1) continue;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; result[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    puts(&quot;&quot;);</span></span><br><span class="line">    <span class="type">double</span> time1 = (<span class="type">double</span>)(<span class="type">tmp_t</span> - <span class="type">start_t</span>) / CLOCKS_PER_SEC * <span class="number">1000</span>;</span><br><span class="line">    <span class="type">double</span> time2 = (<span class="type">double</span>)(<span class="type">end_t</span> - <span class="type">tmp_t</span>) / CLOCKS_PER_SEC * <span class="number">1000</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;朴素解法耗时为&quot;</span> &lt;&lt; (time1) &lt;&lt; <span class="string">&quot;ms\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;strassen分治法耗时为&quot;</span> &lt;&lt; (time2) &lt;&lt; <span class="string">&quot;ms&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="第-k-小元素分治法">第 K 小元素（分治法）</h1><h2 id="题目大意-2">题目大意</h2><p>给定一个长度为 <span class="math inline">\(n\)</span>的整数序列，找出其中第 <span class="math inline">\(k\)</span>小的元素。要求运用分治法思想，编写程序实现该功能，并对算法的正确性、时间复杂度和空间复杂度进行分析，通过实验测试验证算法。</p><h2 id="解法描述-2">解法描述</h2><ol type="1"><li><p><strong>算法思想</strong></p><p>借鉴快速排序的分区思想，将序列划分为两部分。通过不断递归，在合适的子序列中查找第<span class="math inline">\(k\)</span> 小的元素。对于长度较小（小于等于5）的子序列，直接排序后获取第 <span class="math inline">\(k\)</span>小元素；对于长度大于 5 的子序列，先划分为多个大小为 5的子序列，找到这些子序列中位数的中位数作为分界点，根据分界点与<spanclass="math inline">\(k\)</span>的关系，确定下一步搜索的子序列。</p></li><li><p><strong>实现方式</strong></p><p>程序中，<code>paration</code>函数实现类似快速排序的分区操作，以给定元素<code>k</code>（这里是中位数）为基准，将数组分为两部分，使得左边元素小于<code>k</code>，右边元素大于<code>k</code>，并返回分界点位置。<code>select</code>函数用于递归查找第<spanclass="math inline">\(k\)</span>小的元素，当子序列长度小于等于 5时，直接排序返回第<spanclass="math inline">\(k\)</span>小元素；否则，将子序列划分为大小为 5的子序列，排序后将中位数置于数组前部分，递归找到中位数的中位数<code>x</code>，以 <code>x</code>为基准分区，根据 <code>k</code>与分区点位置的关系，在左半部分或右半部分继续递归查找。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：每次递归都能将搜索范围缩小，虽然每次递归处理的子序列规模不同，但总体上递归深度不超过<span class="math inline">\(\logn\)</span>，且每次分区操作时间复杂度为线性 <spanclass="math inline">\(O(n)\)</span>，所以算法时间复杂度为 <spanclass="math inline">\(O(n)\)</span>。</li><li><strong>空间复杂度</strong>：主要取决于递归调用栈的深度，由于每次递归序列规模减半，递归栈深度为<span class="math inline">\(O(\logn)\)</span>，且没有使用其他额外数据结构，所以空间复杂度为 <spanclass="math inline">\(O(\log n)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], pos, k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">paration</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123; <span class="comment">//快排</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == k) &#123;<span class="comment">//k是中位数</span></span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[l]);<span class="comment">//把这个数放到最左端</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> i = l, j = r + <span class="number">1</span>;<span class="comment">//中位数作为基准，不用排</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++;</span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt; k);</span><br><span class="line">        <span class="keyword">do</span> j--;</span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt; k);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[l], a[j]);<span class="comment">//把中位数放回去，此时j的左边都比a[j]即k要小</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在数组a[l...r]中选择第k小的元素返回</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(a + l, a + r + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a[l + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pos = (r - l + <span class="number">1</span>) / <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//每组排序后，将中位数序列置于整个数组的前部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pos; i++) &#123;<span class="comment">//选取每段的中位数</span></span><br><span class="line">        <span class="type">int</span> s = l + <span class="number">5</span> * i;</span><br><span class="line">        <span class="type">int</span> t = s + <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">sort</span>(a + s, a + t + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(a[l + i], a[s + <span class="number">2</span>]);<span class="comment">//将第i组的中位数放置在原数组的第(l + i)位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i = l;i &lt;= pos;i++) printf(&quot;%d &quot;, a[i]);</span></span><br><span class="line">    <span class="comment">//选取中位数序列的中位数</span></span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">select</span>(a, l, l + pos - <span class="number">1</span>, (pos + <span class="number">1</span>) / <span class="number">2</span>);<span class="comment">//这个select一定进入if判断</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">paration</span>(a, l, r, x);<span class="comment">//x就是中位数的中位数，排列完后可以保证i的左右两侧的元素个数相对一致</span></span><br><span class="line">    <span class="type">int</span> j = i - l + <span class="number">1</span>;<span class="comment">//计算此时区间长度</span></span><br><span class="line">    <span class="keyword">if</span> (k == j) <span class="keyword">return</span> a[i];<span class="comment">//因为在if中已经sort了，所以直接就是有序的</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; j) <span class="keyword">return</span> <span class="built_in">select</span>(a, l, i, k);<span class="comment">//对左段排序</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">select</span>(a, i + <span class="number">1</span>, r, k - j);<span class="comment">//对右段排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">select</span>(a, <span class="number">1</span>, n, k));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法设计与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析-第一章</title>
      <link href="/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p><ahref="https://www.luogu.com.cn/record/149769403">推销员问题</a></p><p><ahref="https://www.luogu.com.cn/record/149592866">骑士周游列国</a></p><p>码头扩建</p><p>算法时间复杂度分析</p><span id="more"></span><h1 id="推销员问题tsp">推销员问题（TSP）</h1><h2 id="题目大意">题目大意</h2><p>推销员问题（Traveling SalesmanProblem，TSP）是一个经典的组合优化问题。在该问题中，一个推销员需要访问一系列城市，每个城市只能访问一次，最后必须回到起始城市，目标是找到一条总路径长度最短的路线。从图论角度看，可将城市视为图的节点，城市之间的路径视为图的边，边的权重表示城市间的距离，问题等价于在完全图中寻找<strong>最小权重的哈密尔顿回路</strong>。</p><h2 id="解法描述">解法描述</h2><h3 id="朴素穷举剪枝优化">朴素穷举+剪枝优化</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>通过枚举所有可能的城市访问顺序，计算每种顺序下的路径总长度，从而找出最短路径。利用贪心法进行剪枝，在枚举过程中，如果当前路径长度已经大于已知的最小路径长度，停止对该路径后续情况的枚举。</p></li><li><p><strong>实现方式</strong></p><p>在 C++中，借助 <code>next_permutation</code>函数来枚举所有城市排列。对每个排列，依次计算相邻城市间的距离并累加，得到该排列对应的路径长度。在计算过程中，一旦路径长度超过当前记录的最小路径长度，直接放弃该排列的后续计算。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：朴素穷举的时间复杂度为<spanclass="math inline">\(O(n!)\)</span>，因为需要枚举<spanclass="math inline">\(n\)</span>个城市的所有排列。虽然剪枝优化在一定程度上减少了不必要的计算，但在最坏情况下，时间复杂度仍然是<spanclass="math inline">\(O(n!)\)</span>。当城市数量<spanclass="math inline">\(n\)</span>较大时，计算量会急剧增加，导致算法效率极低。</li><li><strong>空间复杂度</strong>：主要取决于存储每个排列的空间，由于只需要存储一个城市排列序列，所以空间复杂度为<spanclass="math inline">\(O(n)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 朴素解，用next_permutation函数枚举所有城市排列，在所有可能的路径长度中取最小的。最坏时间复杂度为O(n!)</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; cities;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>; <span class="comment">// 视为无穷大</span></span><br><span class="line"><span class="type">int</span> n, final_ans = INF, x; <span class="comment">// 城市数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">ans += g[path[i]][path[i + <span class="number">1</span>]]; <span class="comment">// 从第i个城市到第i+1个城市</span></span><br><span class="line"><span class="keyword">if</span> (ans &gt; final_ans) &#123;</span><br><span class="line"><span class="keyword">return</span> final_ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve_TSP</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cities</span><span class="params">(n)</span></span>;<span class="comment">// 城市遍历序列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cities[i] = i;<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="built_in">compute</span>(cities);</span><br><span class="line">final_ans = <span class="built_in">min</span>(final_ans, tmp);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(cities.<span class="built_in">begin</span>() + <span class="number">1</span>, cities.<span class="built_in">end</span>())); <span class="comment">// 用next_permut交换各个城市的相对位置</span></span><br><span class="line"><span class="keyword">return</span> final_ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">g.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">-1</span>) x = INF;</span><br><span class="line">g[i][j] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">solve_TSP</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划法bellman---held---karp-算法">动态规划法（Bellman - Held- Karp 算法）</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>将原问题划分为多个子问题，通过求解子问题的最优解，逐步构建出原问题的最优解。把所有可能的路径用二进制序列表示，其中1 表示对应城市已走过，0表示未走过。利用状态转移方程，根据已走过城市的状态和当前所在城市，计算出走到下一个未走过城市的最小消耗。</p></li><li><p><strong>实现方式</strong></p><p>定义两个二维数组 <code>dp</code> 和<code>path</code>，<code>dp[i][j]</code> 表示当前走过的城市状态为<code>i</code> （二进制表示）且当前位于城市 <code>j</code>时的最小消耗；<code>path[i][j]</code> 记录走到城市 <code>j</code>（状态为 <code>i</code>时）的前一个城市。通过三层循环，外层循环遍历所有可能的城市状态（从 <spanclass="math inline">\(1\)</span> 到 <span class="math inline">\(2^n -1\)</span>），中层循环在当前状态下遍历所有城市找到已走过的城市<code>u</code>，内层循环遍历所有城市找到未走过的城市<code>v</code>，更新 <code>dp</code> 数组和 <code>path</code>数组。最后，通过遍历所有城市，找到从所有城市回到起始城市的最小路径长度，并根据<code>path</code> 数组回溯出具体路径。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：算法中有三层循环，外层循环遍历<spanclass="math inline">\(2^n\)</span>种城市状态，中层和内层循环分别遍历<spanclass="math inline">\(n\)</span>个城市，所以时间复杂度为<spanclass="math inline">\(O(n^2\times2^n)\)</span>。尽管它仍然是指数级复杂度，但相比朴素穷举的<spanclass="math inline">\(O(n!)\)</span>，在实际计算中，由于利用了子问题的重叠性质，减少了重复计算，通常能在更短时间内找到最优解。</li><li><strong>空间复杂度</strong>：主要由存储子问题最优解的二维数组<code>dp</code> 和 <code>path</code> 决定，它们的大小都是<spanclass="math inline">\((2^n)\times n\)</span>，所以空间复杂度为<spanclass="math inline">\(O(n\times2^n)\)</span>。当<spanclass="math inline">\(n\)</span>较大时，可能会面临内存不足的问题。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用Bellman-Held-Karp算法，时间复杂度O((2^n)*(n^2))</span></span><br><span class="line"><span class="comment">  开两个vector&lt;vector&lt;int&gt;, int&gt;数组，大小为(2^n)*n，以空间换时间</span></span><br><span class="line"><span class="comment">  本算法将所有的可能路径视为二进制序列，1为已经走过，0为未走过。</span></span><br><span class="line"><span class="comment">  不难发现，n个城市一共有2^n种序列，因此遍历他们总共需要2^n次</span></span><br><span class="line"><span class="comment">  同时在每次选取了一个序列后，还需要用双重循环来：1.在已经走过的路径中选择一个出发点 2.选择接下来要走的点（不能已经在集合中），增加将边权加入dist</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//可以处理n=23的问题，并且耗时较少。但是n更大会导致无法分配足够内存而报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> final_ans, n, start_idx;</span><br><span class="line"><span class="comment">//void init() &#123;</span></span><br><span class="line"><span class="comment">////用assign填充</span></span><br><span class="line"><span class="comment">//g.assign(n, vector&lt;int&gt;(n, INF));</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//for (int j = i + 1; j &lt; n; j++) g[i][j] = g[j][i] = rand() % 100 + 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//dp.assign(1 &lt;&lt; n, vector&lt;int&gt;(n, INF));</span></span><br><span class="line"><span class="comment">//path.assign(1 &lt;&lt; n, vector&lt;int&gt;(n, -1));</span></span><br><span class="line"><span class="comment">//start_idx = 0;</span></span><br><span class="line"><span class="comment">//dp[1 &lt;&lt; start_idx][start_idx] = 0; //从0号城市回到0号的距离为0</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bellman_Held_Karp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  dp和path的第一维用于记录当前走过的城市，第二维用于记录本次走到的终点</span></span><br><span class="line"><span class="comment">  dp的值表示走法的最小消耗,path的值表示走终点的前一个点是谁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123; <span class="comment">//遍历2^n-1次，i是十进制表示的二进制序列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123; <span class="comment">//遍历所有点，找到已经在集合中的</span></span><br><span class="line"><span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; u)) &#123; <span class="comment">//1&lt;&lt;u表示二进制序列中第u为是1，用&amp;来判断第u位是否都是1，是则表明点u已经在当前的路径中了</span></span><br><span class="line"><span class="comment">//选取城市u，试图以其为起点走到城市v</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; (<span class="number">1</span> &lt;&lt; v))) &#123; <span class="comment">//如果v还没走过，那就不会形成环路，可以走</span></span><br><span class="line"><span class="keyword">if</span> (dp[i | (<span class="number">1</span> &lt;&lt; v)][v] &gt; dp[i][u] + g[u][v]) &#123;</span><br><span class="line">dp[i | (<span class="number">1</span> &lt;&lt; v)][v]  = (dp[i | (<span class="number">1</span> &lt;&lt; v)][v], dp[i][u] + g[u][v]); <span class="comment">//检测从u走到v是否会使得路径边长，更新路径集合和其对应的值</span></span><br><span class="line">path[i | (<span class="number">1</span> &lt;&lt; v)][v] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加最后构成回环的路径</span></span><br><span class="line"><span class="type">int</span> final_que = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; <span class="comment">//全为1的二进制序列</span></span><br><span class="line">final_ans = INF;</span><br><span class="line"><span class="type">int</span> last_city = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; n; t++) &#123; <span class="comment">//再次遍历所有点</span></span><br><span class="line"><span class="type">int</span> tmp = dp[final_que][t];<span class="comment">//tmp表示走过了所有点后，回到点t</span></span><br><span class="line"><span class="type">int</span> last_w = g[t][start_idx];<span class="comment">//最后一条边的权重</span></span><br><span class="line"><span class="keyword">if</span> (tmp + last_w &lt; final_ans) &#123;</span><br><span class="line">final_ans = tmp + last_w;</span><br><span class="line">last_city = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读出path中存的点作为路径</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path_ans;</span><br><span class="line"><span class="comment">//因为是环路，所以可以从后往前记录</span></span><br><span class="line"><span class="type">int</span> current_city = last_city;</span><br><span class="line"><span class="type">int</span> current_set = final_que;</span><br><span class="line"><span class="keyword">while</span> (current_city != <span class="number">-1</span>) &#123; <span class="comment">//-1是path数组的初始值</span></span><br><span class="line">path_ans.<span class="built_in">push_back</span>(current_city);</span><br><span class="line">current_set ^= (<span class="number">1</span> &lt;&lt; current_city); <span class="comment">//将当前城市从集合中删除</span></span><br><span class="line">current_city = path[current_set | (<span class="number">1</span> &lt;&lt; current_city)][current_city];</span><br><span class="line"><span class="comment">//上一个城市是以这个城市为终点的边的起点，要暂时补回删掉的城市</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;序列表示哈密顿回路&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; start_idx &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : path_ans) &#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_g</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) cout &lt;&lt; g[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="comment">//print_g();</span></span><br><span class="line"><span class="comment">//clock_t start_t = clock();</span></span><br><span class="line"><span class="built_in">Bellman_Held_Karp</span>();</span><br><span class="line"><span class="comment">//clock_t end_t = clock();</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;最短路径权值为&quot; &lt;&lt; final_ans &lt;&lt; endl;</span></span><br><span class="line">cout &lt;&lt; final_ans &lt;&lt; endl;</span><br><span class="line"><span class="comment">//double elapsed_time = (double)(end_t - start_t) / CLOCKS_PER_SEC;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;耗时为&quot; &lt;&lt; (elapsed_time) &lt;&lt; &quot;s&quot;;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="骑士周游列国">骑士周游列国</h1><h2 id="题目大意-1">题目大意</h2><p>在国际象棋 8×8 的棋盘上，给定骑士的初始位置(<spanclass="math inline">\(m\)</span>,<spanclass="math inline">\(n\)</span>)（其中 <spanclass="math inline">\(0\leq m,n\leq 8\)</span>），要求找出一条路径，使骑士不重不漏地经过棋盘上的每一个格子。路径需用8×8的矩阵输出，矩阵中每个元素的值表示骑士到达该位置时行走的步数，起始位置步数为1。</p><h2 id="解法描述-1">解法描述</h2><h3 id="深度优先遍历-dfs">深度优先遍历 DFS</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>深度优先搜索是一种“试错”的搜索策略。从起始位置开始，按照骑士的移动规则，尝试所有可能的走法。若当前走法能继续推进（新位置未被访问过），则标记该位置并递归继续探索；若当前位置的所有走法都无法推进（新位置已被访问或越界），则回溯到上一个位置，尝试其他未探索的走法，直至遍历完整个棋盘或确定不存在可行路径。</p></li><li><p><strong>实现方式</strong></p><p>使用一个二维数组 <code>g[N][N]</code> 表示棋盘，其中<code>N = 8</code>。数组元素值为 0 表示该位置未被访问，非 0值表示骑士到达该位置的步数。定义方向数组 <code>dx[8]</code> 和<code>dy[8]</code> 来表示骑士的 8 种移动方向。在 <code>dfs</code>函数中，每次递归时检查当前位置的 8个可能移动方向，若新位置合法且未被访问，则标记新位置并递归调用<code>dfs</code> 继续探索，若递归返回 <code>true</code>说明找到了可行路径，直接返回；若所有方向都尝试完仍未找到可行路径，则回溯（将新位置标记回0）并返回<code>false</code>。在主函数中，读入起始位置，初始化起始位置的步数为1，调用 <code>dfs</code>函数进行搜索，若找到路径则输出棋盘矩阵，否则输出提示信息。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：在最坏情况下，每个位置都要尝试 8种走法，对于 8×8 的棋盘，共有 64个位置。随着搜索的深入，分支数量呈指数增长，所以时间复杂度约为 <spanclass="math inline">\(O(8^{64})\)</span>，这是一个非常高的时间复杂度，意味着在大规模问题下，算法效率极低。</li><li><strong>空间复杂度</strong>：空间复杂度主要取决于递归调用栈的深度。因为在最坏情况下需要遍历整个棋盘，而每次递归调用都会在栈中占用一定空间，递归深度最大为64，所以空间复杂度为 <span class="math inline">\(O(N^{2})\)</span>，即<span class="math inline">\(O(64)\)</span> 。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  本题需要在8*8棋盘中，从一个点出发找到遍历所有点的一条路径</span></span><br><span class="line"><span class="comment">  关键点：每个点都有8种可能的走法，但是最终只需要找到一条可以遍历所有点的路径</span></span><br><span class="line"><span class="comment">  因此采用dfs递归搜索，并增加返回值以表示当前所走的方向是否正确，确保在找到一条正确路径后就结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, step;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; N &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> step)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (step &gt; <span class="number">64</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 找到路径后返回 true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> tx = x + dx[i], ty = y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(tx, ty) &amp;&amp; g[tx][ty] == <span class="number">0</span>) &#123;</span><br><span class="line">g[tx][ty] = step;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(tx, ty, step + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//如果是合适的路径，那就不需要回溯</span></span><br><span class="line"><span class="keyword">else</span> g[tx][ty] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">g[n][m] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(n, m, <span class="number">2</span>)) &#123;</span><br><span class="line"><span class="comment">// 如果找到路径，输出路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">cout &lt;&lt; g[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No solution found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启发式搜索-warnsdorff-规则">启发式搜索 Warnsdorff 规则</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>Warnsdorff规则是一种启发式策略，其核心是在当前位置选择一阶落点时，优先考察各个一阶落点的可行二阶落点个数，选择可行二阶落点个数最少的一阶落点作为下一步移动方向。这样做的目的是优先选择那些周围“出路”较少的位置，使搜索更有针对性，减少不必要的回溯，提高搜索效率。</p></li><li><p><strong>实现方式</strong></p><p>在原 DFS 代码基础上进行修改。定义一个函数 <code>get_weight</code>来计算某个位置的可行二阶落点个数。在每次选择下一步移动位置时，将所有可行的一阶落点及其权重（可行二阶落点个数）存入一个向量<code>v</code> 中，然后对向量 <code>v</code>按权重从小到大排序。优先尝试权重小的落点进行递归搜索，若找到可行路径则返回，否则回溯继续尝试其他落点。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>在最坏情况下，检查每个位置的邻居时，需要考虑所有可能的移动位置，这里邻居个数<span class="math inline">\(N = 8\)</span>，时间复杂度为 <spanclass="math inline">\(O(N^{2})\)</span>，即 <spanclass="math inline">\(O(8^{2}) = O(64)\)</span>。但实际上，由于Warnsdorff规则的引导，搜索过程会优先选择更有可能成功的路径，大幅减少了搜索范围，基本可在线性时间内检测完棋盘上的所有点，相比朴素DFS 的指数级复杂度有显著优化。</li><li><strong>空间复杂度</strong> 空间复杂度与 DFS类似，主要取决于递归深度或栈的大小。在最坏情况下，同样为 <spanclass="math inline">\(O(N^{2})\)</span> （<spanclass="math inline">\(N\)</span> 是棋盘边长），即 <spanclass="math inline">\(O(64)\)</span>。不过，由于 Warnsdorff规则的引导，搜索路径从八叉树退化为二叉树，使得递归深度降低。虽然这对空间复杂度的理论影响不大，但在实际运行中，对于只需求一个可行解的情况，实际空间利用效率更高，减少了不必要的空间占用。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Warnsdorff规则：</span></span><br><span class="line"><span class="comment">  在当前位置(x,y)选择一阶落点时，先考察各个一阶落点的可行二阶落点个数，选择其中可行二阶落点个数最少一阶落点（以下暂记这个一阶落点为可行方向）</span></span><br><span class="line"><span class="comment">  有效性分析：</span></span><br><span class="line"><span class="comment">  本规则要求每次选择可行方向，不难发现，在周游初期，这个方向一定是存在的。而在后期，如果能完成一次巡游，那么可行方向也必须存在。</span></span><br><span class="line"><span class="comment">  因此可行方向一定可以构成一个正确回路（当然正确回路不一定是由可行方向组成的），由于本题只需要一个解，所以该规则有效</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  综上，在得知Warnsdorff规则后，我们就可以对dfs进行剪枝了，以每个一阶落点的二级落点个数作为权值，从而可以将原来的满8分叉树化简为二叉或三叉树，从而更快地找到一个答案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, PII&gt; PIPII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> g[N][N], x, y;</span><br><span class="line">PII direc[N] = &#123; &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; N &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; N &amp;&amp; g[x][y] == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_g</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">cout &lt;&lt; g[i][j] &lt;&lt; <span class="string">&quot; \n&quot;</span>[j == N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_weight</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tx, ty, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">tx = x + direc[i].x, ty = y + direc[i].y;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ok</span>(tx, ty)) res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> step)</span> </span>&#123; <span class="comment">//设置为bool类型以期在找到答案的第一时间结束递归</span></span><br><span class="line"><span class="keyword">if</span> (step == <span class="number">65</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> tx, ty;</span><br><span class="line">vector&lt;PIPII&gt; v;<span class="comment">//存放本次检测的所有一阶落点和他们的权重</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">tx = x + direc[i].x, ty = y + direc[i].y;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ok</span>(tx, ty))v.<span class="built_in">push_back</span>(&#123;<span class="built_in">get_weight</span>(tx, ty), &#123;tx, ty&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> t : v) &#123;</span><br><span class="line">g[t.y.x][t.y.y] = step;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(t.y.x, t.y.y, step + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">g[t.y.x][t.y.y] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">g[x][y] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x, y, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">print_g</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种可能的周游路径如下： <img src="img.png" title="img"alt="img" /></p><h1 id="码头扩建问题">码头扩建问题</h1><h2 id="题目大意-2">题目大意</h2><p>某市有一码头，每次仅允许一艘船停泊装卸货。根据历史资料，码头平均每月停船24 艘，每艘船的停泊时间为 24±20 小时，相邻两艘船的到达时间间隔为 30±15小时。若一艘船因有其他船在港而等候 1 小时，其消耗成本为 1000元。扩建码头大约需要 1350万元。要求通过程序随机产生到达时间和停泊时间，模拟未来五年内船的停泊情况，多次模拟预测停泊情况，以判断未来五年内停泊船只因等候的成本消耗总和是否超过扩建码头花费，从而帮助市长做出是否扩建码头的决策。</p><h2 id="解法描述-2">解法描述</h2><h3 id="离散事件模拟算法">离散事件模拟算法</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>利用离散事件模拟的方法，将未来五年的时间按月划分，通过循环模拟每个月内船只的到达和停泊过程。在模拟过程中，借助随机数生成符合条件的船只到达时间间隔和停泊时间，根据船只到达时码头的状态（是否有船正在停泊）来计算等待时间和成本，最后累加所有模拟次数的成本并求平均，与扩建码头的成本阈值进行比较，得出是否扩建的结论。</p></li><li><p><strong>实现方式</strong></p><p>在 C++中，使用 <code>&lt;random&gt;</code>库生成随机数。<code>random_device rd</code>用于生成随机数种子，<code>mt19937 gen(rd())</code>创建一个基于种子的随机数生成器。通过两层嵌套循环进行模拟，外层循环控制模拟的总次数（如1000 次），内层循环模拟每个月（共 60个月）的情况。对于每个月，假设第一艘船在最开始到达，生成其停泊时间。后续船只根据上一艘船的到达和停泊时间计算自身到达时间，若到达时上一艘船还在停靠，则计算等待成本，更新停泊时间；若无需等待，则直接更新停泊时间。每次模拟结束后累加总成本，最后根据总成本与扩建成本阈值的比较结果输出决策信息。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：外层循环执行次数为模拟总次数，设为<code>test</code>，时间复杂度为 <spanclass="math inline">\(O(test)\)</span>。内层循环执行 60次，内层循环中的计算操作，如随机数生成、条件判断和成本计算等，都是常数时间操作，时间复杂度为<span class="math inline">\(O(1)\)</span>。所以总体时间复杂度为 <spanclass="math inline">\(O(test×1)\)</span>，即 <spanclass="math inline">\(O(test)\)</span>。当模拟次数增加时，运行时间会线性增长。</li><li><strong>空间复杂度</strong>：程序中主要使用了几个整型变量（如<code>spend</code>、<code>dock_time</code>、<code>arrival_time</code>等）和一个长整型变量（<code>cost</code>）来存储数据，这些变量占用的存储空间是常数级别的。随机数生成器的存储空间与生成器的状态大小相关，但在本实验中，其状态大小也是常数级别的，不会对空间复杂度产生显著影响。因此，总体空间复杂度为<span class="math inline">\(O(1)\)</span>，即无论模拟次数和数据规模如何变化，程序占用的空间基本保持不变。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  为了简化情况，本模拟将五年按月划分开，即以一个月为基础编写代码，并循环5*12次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span>  Max = <span class="number">1.35e7</span>;</span><br><span class="line"><span class="type">int</span> spend, pre = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> dock_time, arrival_time;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cost, tmp_cost;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line">random_device rd;<span class="comment">//声名一个随机数种子对象。命名为rd</span></span><br><span class="line"><span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;<span class="comment">//创建了一个 mt19937 类的对象，它使用前面声明的 rd 对象生成的种子进行构造。这个对象被命名为 gen。</span></span><br><span class="line"><span class="comment">//uniform_int_distribution&lt;&gt;，均匀分布的随机数生成器</span></span><br><span class="line"><span class="comment">//下述的arrival_interval和docking_time是一个类，接受gen作为参数</span></span><br><span class="line">uniform_int_distribution&lt;&gt; <span class="built_in">arrival_interval</span>(<span class="number">15</span>, <span class="number">45</span>);<span class="comment">//到达时间</span></span><br><span class="line">uniform_int_distribution&lt;&gt; <span class="built_in">docking_time</span>(<span class="number">4</span>, <span class="number">44</span>);<span class="comment">//停泊时间</span></span><br><span class="line"><span class="comment">//进行一千次模拟</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= <span class="number">1000</span>; t++) &#123;</span><br><span class="line">tmp_cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> month = <span class="number">1</span>; month &lt;= <span class="number">60</span>; month++) &#123;</span><br><span class="line"><span class="comment">//不考虑从月末停留到月初的情况</span></span><br><span class="line"><span class="comment">//不妨假设第一艘船是在最开始到达的</span></span><br><span class="line">dock_time = arrival_time = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ship = <span class="number">1</span>; ship &lt;= <span class="number">24</span>; ship++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ship == <span class="number">1</span>) &#123;</span><br><span class="line">dock_time = <span class="built_in">docking_time</span>(gen);<span class="comment">//开始卸货</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//本船到达</span></span><br><span class="line">arrival_time += <span class="built_in">arrival_interval</span>(gen);<span class="comment">//增加表示间隔时间</span></span><br><span class="line"><span class="keyword">if</span> (arrival_time &lt; dock_time) &#123;</span><br><span class="line"><span class="comment">//到达时上一艘船还在停靠</span></span><br><span class="line"></span><br><span class="line">tmp_cost += (dock_time - arrival_time) * pre;</span><br><span class="line">dock_time += <span class="built_in">docking_time</span>(gen); <span class="comment">//本船还不能进港操作，必须等上一只船结束</span></span><br><span class="line">&#125; <span class="keyword">else</span> dock_time = arrival_time + <span class="built_in">docking_time</span>(gen); <span class="comment">//无需等待，那就是入港时间加自身卸货</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dock_time = docking_time(gen);</span></span><br><span class="line"><span class="comment">//arrival_time = arrival_interval(gen);</span></span><br><span class="line"><span class="comment">//if (dock_time &gt; arrival_time) tmp_cost += 1000 * (dock_time - arrival_time);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cost += tmp_cost / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cost &gt; Max) cout &lt;&lt; <span class="string">&quot;超支了&quot;</span> &lt;&lt; cost - Max &lt;&lt; <span class="string">&quot;元&quot;</span> &lt;&lt; <span class="string">&quot;应该扩建&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;距离超支还有%lld元，不用扩建&quot;</span>, (Max - cost));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法时间复杂度的实验测试">算法时间复杂度的实验测试</h1><h2 id="题目大意-3">题目大意</h2><p>运用编程工具对堆排序或快速排序算法进行时间复杂度测试，通过在不同输入规模下运行算法并记录运行时间，从而学会通过实验分析算法的时间复杂度。</p><h2 id="解法描述-3">解法描述</h2><h3 id="堆排序算法">堆排序算法</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>基于二叉堆数据结构，以构建大根堆为例实现从小到大排序。首先将输入数组进行堆化操作，使每个节点都满足大根堆性质，即父节点的值大于等于子节点的值。然后不断将堆顶元素（最大值）与数组末尾元素交换，将最大值放到数组末尾，接着对交换后的堆进行调整，维持堆的性质，重复该过程直到整个数组有序。</p></li><li><p><strong>实现方式</strong></p><p>在 C++代码中，定义数组 <code>heap[N]</code>存储待排序数据，<code>N</code> 为数组最大容量。<code>down</code>函数用于调整堆，在函数中，通过比较当前节点与其左右子节点的值，将最大值交换到当前节点位置，并递归向下调整。在<code>main</code> 函数中，利用 <code>&lt;random&gt;</code>库生成随机数填充数组。排序前使用 <code>clock()</code>函数记录起始时间，排序过程先对数组进行堆化（从 <code>n/2</code> 到<code>0</code> 调用 <code>down</code>函数），然后通过不断交换堆顶和末尾元素并调整堆（共 <code>n</code>次）实现排序。排序结束后再次使用 <code>clock()</code>函数记录结束时间，计算并输出排序耗时。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：堆排序的时间复杂度为 <spanclass="math inline">\(O(n log n)\)</span>。堆构建阶段，从<code>n/2</code> 到 <code>0</code> 调用 <code>down</code>函数，每次调整操作的时间复杂度为 <span class="math inline">\(O(logn)\)</span>，总共进行约 <span class="math inline">\(n/2\)</span>次，时间复杂度为 <span class="math inline">\(O(n log n)\)</span>；排序阶段，进行 <code>n</code>次交换和调整堆操作，每次调整堆的时间复杂度也是 <spanclass="math inline">\(O(log n)\)</span>，整体排序阶段时间复杂度同样为<span class="math inline">\(O(n log n)\)</span>。</li><li><strong>空间复杂度</strong>：堆排序仅使用了常数级别的额外空间，如在调整堆过程中临时变量的存储，因此空间复杂度为<span class="math inline">\(O(1)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> heap[N];<span class="comment">//大根堆实现从小到大排列</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = idx;</span><br><span class="line"><span class="comment">//大根堆的根应该是最大的</span></span><br><span class="line"><span class="comment">//在idx，2*idx+1，2*idx三者中找到值最大的那一个</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> * idx &lt;= n &amp;&amp; heap[tmp] &lt; heap[idx * <span class="number">2</span>]) tmp = idx * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> * idx + <span class="number">1</span> &lt;= n &amp;&amp; heap[tmp] &lt; heap[idx * <span class="number">2</span> + <span class="number">1</span>]) tmp = idx * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp != idx) &#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[idx], heap[tmp]);<span class="comment">//让最大值来到根的位置</span></span><br><span class="line"><span class="built_in">down</span>(tmp);<span class="comment">//递归向下交换，使小的值向下，大的值向上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成随机数构造器</span></span><br><span class="line">random_device rd;<span class="comment">//声名一个随机数种子对象。命名为rd</span></span><br><span class="line"><span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;<span class="comment">//创建了一个 mt19937 类的对象，它使用前面声明的 rd 对象生成的种子进行构造。这个对象被命名为 gen。</span></span><br><span class="line">uniform_int_distribution&lt;&gt; <span class="built_in">random_num</span>(<span class="number">0</span>, <span class="number">10000000</span>);<span class="comment">//均匀分布的随机数</span></span><br><span class="line"><span class="comment">//填充随机数</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="comment">//从一开始存避免找子节点时找到自己</span></span><br><span class="line">heap[i] = <span class="built_in">random_num</span>(gen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序开始</span></span><br><span class="line"><span class="type">clock_t</span> <span class="type">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="built_in">down</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[<span class="number">1</span>], heap[n]);<span class="comment">//交换n次，将大值放在尾部，相当于从堆里剔除</span></span><br><span class="line">n--;</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">clock_t</span> <span class="type">end_t</span> = <span class="built_in">clock</span>();</span><br><span class="line"><span class="type">double</span> elapsed_time = (<span class="type">double</span>)(<span class="type">end_t</span> - <span class="type">start_t</span>) / CLOCKS_PER_SEC * <span class="number">1000</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;耗时为&quot;</span> &lt;&lt; (elapsed_time) &lt;&lt; <span class="string">&quot;ms&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序算法">快速排序算法</h3><ol type="1"><li><p><strong>算法思想</strong></p><p>采用分治策略。选择一个基准元素，将数组分为两个子数组，使得左边子数组的元素都小于基准元素，右边子数组的元素都大于基准元素。然后递归地对左右子数组进行排序，最后合并各个有序子数组得到最终的有序数组。</p></li><li><p><strong>实现方式</strong></p><p>代码中定义数组 <code>q[N]</code> 存储数据。<code>quick_sort</code>函数实现快速排序逻辑，函数中先选取一个基准元素（这里取数组中间元素<code>q[(l + r) &gt;&gt; 1]</code>），通过双指针 <code>i</code>和<code>j</code>从数组两端向中间扫描，将小于基准的元素放到左边，大于基准的元素放到右边。当<code>i</code> 和 <code>j</code>相遇时，完成一次划分，接着递归对左右子数组进行排序。在 <code>main</code>函数中，同样利用 <code>&lt;random&gt;</code>库生成随机数填充数组，记录排序前后的时间，计算并输出排序耗时。</p></li><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：快速排序平均时间复杂度为 <spanclass="math inline">\(O(n logn)\)</span>。在平均情况下，每次划分都能将数组大致均匀分成两部分，递归深度为<span class="math inline">\(log n\)</span>，每层划分操作的时间复杂度为<span class="math inline">\(O(n)\)</span>，整体时间复杂度为 <spanclass="math inline">\(O(n logn)\)</span>。但在最坏情况下，如每次选取的基准元素都是数组中的最大或最小值，划分会极度不均匀，时间复杂度会退化为<span class="math inline">\(O(n^2)\)</span> 。</li><li><strong>空间复杂度</strong>：快速排序的空间复杂度主要取决于递归调用的栈空间。平均情况下，递归深度为<span class="math inline">\(log n\)</span>，因此空间复杂度为 <spanclass="math inline">\(O(log n)\)</span>；在最坏情况下，递归深度达到<span class="math inline">\(n\)</span>，空间复杂度为 <spanclass="math inline">\(O(n)\)</span> 。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> q[N];<span class="comment">//大根堆实现从小到大排列</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//左右指针相遇</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x = q[(l + r) &gt;&gt; <span class="number">1</span>]; <span class="comment">//随便取一个标定</span></span><br><span class="line"><span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;<span class="comment">//选不可能点</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">do</span> i++;</span><br><span class="line"><span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line"><span class="keyword">do</span> j--;</span><br><span class="line"><span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line"><span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束后[l,j]的数都比x要小，[j+1,r]的数都比x要大</span></span><br><span class="line"><span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成随机数构造器</span></span><br><span class="line">random_device rd;<span class="comment">//声名一个随机数种子对象。命名为rd</span></span><br><span class="line"><span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;<span class="comment">//创建了一个 mt19937 类的对象，它使用前面声明的 rd 对象生成的种子进行构造。这个对象被命名为 gen。</span></span><br><span class="line">uniform_int_distribution&lt;&gt; <span class="built_in">random_num</span>(<span class="number">0</span>, <span class="number">10000000</span>);<span class="comment">//均匀分布的随机数</span></span><br><span class="line"><span class="comment">//填充随机数</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">q[i] = <span class="built_in">random_num</span>(gen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">clock_t</span> <span class="type">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="type">clock_t</span> <span class="type">end_t</span> = <span class="built_in">clock</span>();</span><br><span class="line"><span class="type">double</span> elapsed_time = (<span class="type">double</span>)(<span class="type">end_t</span> - <span class="type">start_t</span>) / CLOCKS_PER_SEC * <span class="number">1000</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;耗时为&quot;</span> &lt;&lt; (elapsed_time) &lt;&lt; <span class="string">&quot;ms&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法设计与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一讲-排序与枚举</title>
      <link href="/2025/02/28/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9E%9A%E4%B8%BE/"/>
      <url>/2025/02/28/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="作业链接">作业链接</h1><p><a href="https://www.luogu.com.cn/training/714006">[蓝桥杯]第一讲：排序与枚举 - 题单 - 洛谷 | 计算机科学教育新生态</a></p><h1 id="ac-代码">AC 代码</h1><span id="more"></span><h2 id="p1177-模板排序---洛谷"><ahref="https://www.luogu.com.cn/problem/P1177">P1177 【模板】排序 -洛谷</a></h2><p>知识点：sort 函数</p><p>学习怎么使用 sort 将数组变为升序有序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+9</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 读取整数n</span></span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 读取n个整数并存储到列表a中</span></span><br><span class="line"></span><br><span class="line">a.sort()  <span class="comment"># 对列表a进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出排序后的结果，每个数字后跟一个空格</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, a)))</span><br></pre></td></tr></table></figure><h2 id="p1271-深基-9.例-1选举学生会---洛谷"><ahref="https://www.luogu.com.cn/problem/P1271">P1271 【深基 9.例1】选举学生会 - 洛谷</a></h2><p>知识点：桶排序</p><p>数组下标本身就是有序的，可以根据值域考虑使用下标来实现有序化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">p[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (p[i]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">p[i]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p10901-蓝桥杯-2024-省-c-封闭图形个数---洛谷"><ahref="https://www.luogu.com.cn/problem/P10901">P10901 [蓝桥杯 2024 省 C]封闭图形个数 - 洛谷</a></h2><p>知识点：自定义排序函数</p><p>基础的 sort 函数只能升序排列，通过手写 cmp函数可以实现自定义的排序方法。cmp 是一种 bool类型的函数，通过比较传入的两个值，保证相邻的 x 和 y符合我们定义的规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> mp[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span><span class="number">+9</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; y)flg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x) &#123;</span><br><span class="line">cnt1 += mp[x % <span class="number">10</span>];</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (y) &#123;</span><br><span class="line">cnt2 += mp[y % <span class="number">10</span>];</span><br><span class="line">y /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt1 == cnt2)<span class="keyword">return</span> flg;</span><br><span class="line"><span class="keyword">return</span> cnt1 &lt; cnt2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a, a + n, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p8732-蓝桥杯-2020-国-abc-答疑---洛谷"><ahref="https://www.luogu.com.cn/problem/P8732">P8732 [蓝桥杯 2020 国 ABC]答疑 - 洛谷</a></h2><p>知识点：贪心</p><p>排序往往不是单独的考点，而是作为贪心题目的实现方式。所谓贪心是将待处理的数据按照一定的顺序进行排列，贪心地处理局部最优，从而实现全局最优。要对数组排列，就需要一种满足题意的排序方式，这种方式不同于之前的题目是直接给出的，而是需要我们进行推导的。一种常见的思考方式是“微扰法”，即只考虑相邻两项在交换前和交换后的两种代价，通过假定某种代价更优，找到cmp 函数的不等式写法。</p><p>本题中考虑相邻的学生为 则交换前两位同学的总代价为：</p><p><span class="math display">\[(s_i + a_i)+(s_{i} + a_{i} + e_{i} + s_{i + 1} + a_{i + 1})\]</span></p><p>交换后的总代价为：</p><p><span class="math display">\[s_{i + 1} + a_{i + 1}+(s_{i + 1} + a_{i + 1} + e_{i+1} + s_{i} + a_{i})\]</span></p><p>不妨假设交换前更优，则有：</p><p><span class="math display">\[\begin{aligned}&amp;(s_i + a_i)+(s_{i} + a_{i} + e_{i} + s_{i + 1} + a_{i + 1})&amp;&lt;&amp; \ s_{i + 1} + a_{i + 1}+(s_{i + 1} + a_{i + 1} + e_{i+1}+ s_{i} + a_{i})\\&amp;2s_i + 2a_i + e_{i} + s_{i + 1} + a_{i + 1} &amp;&lt;&amp; \ 2s_{i+ 1} + 2a_{i + 1} + e_{i+1} + s_{i} + a_{i}\\&amp;s_i + a_i + e_{i} &amp;&lt;&amp; \ s_{i + 1} + a_{i + 1} + e_{i+1}\end{aligned}\]</span></p><p>因此得到 cmp 函数的写法为将的和较小的靠前放这一结论，这便是排序方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">贪心</span></span><br><span class="line"><span class="comment">要求发送消息的时刻最小，微扰法分析</span></span><br><span class="line"><span class="comment">微扰：是用相邻两项进行交换从而验证两项其中的一个怎么样才会使得最后答案最优，并以此确定排序方式的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">ll s, a, e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span><span class="number">+9</span>;</span><br><span class="line">ll n, ans, now;</span><br><span class="line">node st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x.s + x.a + x.e) &lt; (y.s + y.a + y.e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 显然谁的总耗时更长谁应该更晚进入</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; st[i].s &gt;&gt; st[i].a &gt;&gt; st[i].e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(st, st + n, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">ans += now + st[i].s + st[i].a;<span class="comment">// 第 i 位同学发送消息的时刻不包括 st[i].e</span></span><br><span class="line">now += st[i].s + st[i].a + st[i].e;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b3623-枚举排列递归实现排列型枚举---洛谷"><ahref="https://www.luogu.com.cn/problem/B3623">B3623枚举排列（递归实现排列型枚举） - 洛谷</a></h2><p>知识点：深搜枚举集合，next_permutation 与去重</p><p>深搜过程以 <span class="math inline">\(n=3,k=2\)</span> 举例：</p><p><img src="dfs_image.png" title="n = 3 , k = 2" alt="img" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)ans.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> t : ans) &#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">// 此处顺序枚举保证了字典序</span></span><br><span class="line"><span class="keyword">if</span> (vis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">vis[i] = <span class="number">1</span>;</span><br><span class="line">ans.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="built_in">dfs</span>();</span><br><span class="line">ans.<span class="built_in">pop_back</span>();</span><br><span class="line">vis[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">dfs</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;string&gt; s;<span class="comment">// 去重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">a[i] = i + <span class="number">1</span>; <span class="comment">// 初始化数组为1到n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(a.begin(), a.begin() + k)</span></span>; <span class="comment">// 截取前 k 个数字</span></span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> t : tmp) &#123;</span><br><span class="line">str += t + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">count</span>(str))<span class="keyword">continue</span>;</span><br><span class="line">s.<span class="built_in">insert</span>(str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> t : tmp) &#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>())); <span class="comment">// 生成下一个排列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="p8599-蓝桥杯-2013-省-b-带分数---洛谷"><ahref="https://www.luogu.com.cn/problem/P8599">P8599 [蓝桥杯 2013 省 B]带分数 - 洛谷</a></h2><p>知识点：next_permutation 用法，字符串划分，字符串转数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;<span class="comment">// 最大可表示 10^16</span></span><br><span class="line"><span class="type">int</span> ans, len;</span><br><span class="line">ll n;</span><br><span class="line">string s;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n = a + b/c &lt;-&gt; n * c = a * c + b</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ll <span class="title">str_to_num</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">// 左闭右闭</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = l;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 左侧高位写法</span></span><br><span class="line">ans = ans*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 对每个情况都切出三个数字，因此只需要两个标记，但要保证有三个数字</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a = <span class="built_in">str_to_num</span>(<span class="number">0</span>,i), b = <span class="built_in">str_to_num</span>(i<span class="number">+1</span>,j), c = <span class="built_in">str_to_num</span>(j<span class="number">+1</span>,len<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ( n * c == a * c + b)ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">s = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">len = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">check</span>();</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()));</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p10385-蓝桥杯-2024-省-a-艺术与篮球---洛谷"><ahref="https://www.luogu.com.cn/problem/P10385">P10385 [蓝桥杯 2024 省 A]艺术与篮球 - 洛谷</a></h2><p>知识点：c++ 手写日历，python 日期相关模块的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;<span class="comment">// 最大可表示 10^16</span></span><br><span class="line"><span class="comment">// 字符向数字映射</span></span><br><span class="line"><span class="type">int</span> mp[] = &#123;<span class="number">13</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">2000</span>, m = <span class="number">1</span>, d = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> day[] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闰年闰月判断</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (m==<span class="number">2</span>) &amp;&amp; ((y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>) || y % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">tmp += mp[a % <span class="number">10</span>];</span><br><span class="line">a /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">tmp += mp[b % <span class="number">10</span>];</span><br><span class="line">b /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">tmp += mp[c % <span class="number">10</span>];</span><br><span class="line">c /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp &gt; <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(y, m, d))ans++;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">2024</span> &amp;&amp; m == <span class="number">4</span> &amp;&amp; d == <span class="number">13</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 日期变化</span></span><br><span class="line">d++;</span><br><span class="line"><span class="keyword">if</span>(d&gt;day[m]+<span class="built_in">add</span>())</span><br><span class="line">&#123;</span><br><span class="line">d = <span class="number">1</span>;</span><br><span class="line">m++;</span><br><span class="line"><span class="keyword">if</span>(m&gt;<span class="number">12</span>)</span><br><span class="line">&#123;</span><br><span class="line">m = <span class="number">1</span>;</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义映射数组</span></span><br><span class="line">mp = [<span class="number">13</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义检查函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">y, m, d</span>):</span><br><span class="line">    tmp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> digit <span class="keyword">in</span> <span class="built_in">str</span>(y):// 转化为字符串后逐个映射</span><br><span class="line">        tmp += mp[<span class="built_in">int</span>(digit)]</span><br><span class="line">    <span class="keyword">for</span> digit <span class="keyword">in</span> <span class="built_in">str</span>(m).zfill(<span class="number">2</span>):// 对字符串零填充</span><br><span class="line">        tmp += mp[<span class="built_in">int</span>(digit)]</span><br><span class="line">    <span class="keyword">for</span> digit <span class="keyword">in</span> <span class="built_in">str</span>(d).zfill(<span class="number">2</span>):</span><br><span class="line">        tmp += mp[<span class="built_in">int</span>(digit)]</span><br><span class="line">    <span class="keyword">return</span> tmp &gt; <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化起始日期和结束日期</span></span><br><span class="line">start_date = datetime(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">end_date = datetime(<span class="number">2024</span>, <span class="number">4</span>, <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化答案计数</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历日期</span></span><br><span class="line">current_date = start_date</span><br><span class="line"><span class="keyword">while</span> current_date &lt;= end_date:</span><br><span class="line">    <span class="keyword">if</span> check(current_date.year, current_date.month, current_date.day):</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line">    current_date += timedelta(days=<span class="number">1</span>)// 更新日期</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h2 id="p8772-蓝桥杯-2022-省-a-求和---洛谷"><ahref="https://www.luogu.com.cn/problem/P8772">P8772 [蓝桥杯 2022 省 A]求和 - 洛谷</a></h2><p>知识点：前缀和、推式子</p><p>原始式子为：</p><p><span class="math display">\[S = a_1(a_2 + a_3 + \cdots + a_n) + a_2(a_3 + \cdots + a_n) + \cdots +a_{n - 1}a_n\]</span></p><p>如果暴力求每一项，则总的时间复杂度为 。</p><p>观察到每一项乘积其实是 <span class="math inline">\(a_i\)</span> 与<span class="math inline">\(\sum_{k=1}^n a_k - \sum_{k=1}^i a_k\)</span>的积，而此处的求和式子可以用前缀和维护从而避免每次都循环计算，将求每项的复杂度从降为 。推导出新的式子为：</p><p><span class="math display">\[S = \sum_{i = 1}^{n}\left( a_{i} \times (\sum_{k = 1}^{n} a_{k} -\sum_{k = 1}^{i} a_{k})\right)\]</span></p><p>新式子的时间复杂度为外层求和，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">2e5</span><span class="number">+9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll a[N],s[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) s[i] = a[i];</span><br><span class="line">        <span class="keyword">else</span> s[i] += s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = s[n];<span class="comment">//所有数的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += a[i]*(sum - s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p8708-蓝桥杯-2020-省-a1-整数小拼接---洛谷"><ahref="https://www.luogu.com.cn/problem/P8708">P8708 [蓝桥杯 2020 省 A1]整数小拼接 - 洛谷</a></h2><p>知识点：双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"></span><br><span class="line">ll n, k;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+9</span>;</span><br><span class="line"></span><br><span class="line">ll a[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 库函数实现数字拼接</span></span><br><span class="line"><span class="comment">//return stoll(to_string(a[i])+to_string(a[j]))&lt;=k;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手写</span></span><br><span class="line">ll x = a[i], y = a[j];</span><br><span class="line"><span class="keyword">while</span> (y) &#123;</span><br><span class="line">x *= <span class="number">10</span>, y /= <span class="number">10</span>; <span class="comment">// x 前移给 y 留出位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x + a[j] &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先保证有序</span></span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>, r = n; <span class="comment">// 双指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 不能是同一个数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(l, r)) &#123;</span><br><span class="line"><span class="comment">// 合法，说明这个 l 之后（l+1）到 r 的数字按照 l,r 的顺序拼接都合法</span></span><br><span class="line">ans += r - l;</span><br><span class="line">l++;<span class="comment">// 左边界移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> r--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意反向拼接也合法</span></span><br><span class="line">l = <span class="number">1</span>, r = n;<span class="comment">// 重新赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(r, l)) &#123; <span class="comment">// 只需要交换拼接的方式</span></span><br><span class="line">ans += r - l;</span><br><span class="line">l++;</span><br><span class="line">&#125; <span class="keyword">else</span> r--;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计竞赛 </category>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计竞赛 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
