<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法设计与分析-第二章</title>
      <link href="/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<ul><li>二分检索（分治法）<ahref="https://www.luogu.com.cn/record/150679164">记录详情 - 洛谷 |计算机科学教育新生态</a></li><li>矩阵乘法（分治法）<ahref="https://www.luogu.com.cn/record/150682327">记录详情 - 洛谷 |计算机科学教育新生态</a></li><li>第 K 小元素（分治法）<ahref="https://www.luogu.com.cn/record/150680931">记录详情 - 洛谷 |计算机科学教育新生态</a></li></ul><span id="more"></span><h1 id="二分检索分治法">二分检索（分治法）</h1><h2 id="题目大意">题目大意</h2><p>给定一个大小为 <span class="math inline">\(n\)</span> 的递增整数序列<span class="math inline">\(L\)</span>，使用二分查找法查找任意元素 <spanclass="math inline">\(x\)</span> 在序列中的位置 <spanclass="math inline">\(k\)</span>（即序列中的第几个元素），若元素不存在则返回-1。要求编写程序实现二分查找算法，并对其时间复杂度和空间复杂度进行分析，同时通过实验评估算法性能。</p><h2 id="解法描述">解法描述</h2><ol type="1"><li><strong>算法思想</strong>：二分查找算法基于分治思想，适用于有序数组。其核心是将待查找区间不断二分，通过比较中间元素与目标元素的大小关系，确定目标元素可能存在的新区间，逐步缩小查找范围，直到找到目标元素或确定其不存在。</li><li><strong>实现方式</strong>：程序中，先接收输入的序列大小 <spanclass="math inline">\(n\)</span>、序列 <spanclass="math inline">\(L\)</span> 以及要查找的元素 <spanclass="math inline">\(x\)</span>。初始化左右指针 <code>left = -1</code>和 <code>right = n</code>，在 <code>left &lt; right</code>的循环中，计算中间元素下标 <code>mid = (left + right) / 2</code>。若<code>a[mid] &gt;= x</code>，说明目标元素可能在左半部分，更新<code>right = mid</code>；若<code>a[mid] &lt; x</code>，则目标元素在右半部分，更新<code>left = mid + 1</code>。循环结束后，判断 <code>a[left]</code>是否等于目标元素 <code>x</code>，若相等则返回<code>left</code>，否则返回 -1。</li><li><strong>复杂度分析</strong>：<ul><li><strong>时间复杂度</strong>：每次迭代都将待查找区间减半，假设序列大小为<span class="math inline">\(n\)</span>，最多需要进行 <spanclass="math inline">\(\log n\)</span>次迭代就能找到目标元素或确定其不存在，所以时间复杂度为 <spanclass="math inline">\(O(\log n)\)</span>。</li><li><strong>空间复杂度</strong>：算法执行过程中，除输入数据外，仅使用了几个辅助变量（如<code>left</code>、<code>right</code>、<code>mid</code>），这些变量占用的空间不随输入规模<span class="math inline">\(n\)</span> 的变化而变化，因此空间复杂度为<span class="math inline">\(O(1)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100009</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (a[l] == x ? l : <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵乘法分治法">矩阵乘法（分治法）</h1><h2 id="题目大意-1">题目大意</h2><p>给定两个矩阵 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span>，使用分治法实现矩阵乘法，并与朴素矩阵乘法算法进行比较。要求编写程序实现相关算法，分析算法的正确性、时间复杂度和空间复杂度，并通过实验测试评估算法性能。</p><h2 id="解法描述-1">解法描述</h2><ol type="1"><li><strong>算法思想</strong>：<ul><li><strong>朴素矩阵乘法</strong>：根据矩阵乘法定义，结果矩阵 <spanclass="math inline">\(C\)</span> 的每个元素 <spanclass="math inline">\(C_{ij}\)</span> 是矩阵 <spanclass="math inline">\(A\)</span> 的第 <spanclass="math inline">\(i\)</span> 行与矩阵 <spanclass="math inline">\(B\)</span> 的第 <spanclass="math inline">\(j\)</span>列对应元素乘积之和。通过三重循环遍历实现，时间复杂度较高，为 <spanclass="math inline">\(O(n^3)\)</span>。</li><li><strong>Strassen分治算法</strong>：基于分治策略，将大矩阵乘法问题分解为多个小规模子矩阵乘法问题。把输入矩阵<span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span>各划分为四个大小相等的子矩阵，通过特定的加减法和 7次递归的子矩阵乘法，再进行线性组合得到结果矩阵。这种方法减少了乘法次数，理论上时间复杂度为<span class="math inline">\(O(n^{2.7})\)</span>。</li></ul></li><li><strong>实现方式</strong>：<ul><li><strong>矩阵表示</strong>：使用二维向量<code>vector&lt;vector&lt;int&gt;&gt;</code>表示矩阵，方便对矩阵元素进行访问和操作。</li><li><strong>辅助函数</strong>：实现矩阵加法 <code>matrixAdd</code>和减法 <code>matrixSubtract</code> 函数，用于 Strassen算法中矩阵的加减运算；实现朴素矩阵乘法 <code>matrixMultiply</code>函数，通过三重循环计算结果矩阵。</li><li><strong>Strassen 算法实现</strong>：在 <code>strassen</code>函数中，先处理矩阵规模为 2的基本情况，直接调用朴素矩阵乘法。对于更大规模矩阵，将其分割为子矩阵，计算中间矩阵<spanclass="math inline">\(S_i\)</span> ，递归计算 7 个乘积矩阵 <spanclass="math inline">\(M_i\)</span> ，最后通过线性组合得到结果矩阵 <spanclass="math inline">\(C\)</span> 的四个子矩阵 <spanclass="math inline">\(C_{11}\)</span>、<spanclass="math inline">\(C_{12}\)</span>、<spanclass="math inline">\(C_{21}\)</span>、<spanclass="math inline">\(C_{22}\)</span>，并组合成最终结果矩阵。</li></ul></li><li><strong>复杂度分析</strong>：<ul><li><strong>朴素矩阵乘法</strong>：<ul><li><strong>时间复杂度</strong>：有三层嵌套循环，每层循环次数都为矩阵大小<span class="math inline">\(n\)</span>，所以时间复杂度为 <spanclass="math inline">\(O(n^3)\)</span>。</li><li><strong>空间复杂度</strong>：仅使用一个结果矩阵存储最终乘积，空间复杂度为<span class="math inline">\(O(n^2)\)</span>。</li></ul></li><li><strong>Strassen 分治算法</strong>：<ul><li><strong>时间复杂度</strong>：通过减少乘法次数，理论时间复杂度降为<spanclass="math inline">\(O(n^{2.7})\)</span>，但由于常数项较大，在小规模矩阵时效率可能不如朴素算法。</li><li><strong>空间复杂度</strong>：与朴素矩阵乘法相同，都需要一个结果矩阵存储最终结果，空间复杂度为<span class="math inline">\(O(n^2)\)</span>。</li></ul></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, N;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; VVI;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="comment">////将矩阵扩展为2的倍数</span></span><br><span class="line"><span class="comment">//VVI extendMatrix(const VVI&amp; A) &#123;</span></span><br><span class="line"><span class="comment">//    int originalSize = A.size();</span></span><br><span class="line"><span class="comment">//    int newSize = (originalSize % 2 == 0 ? originalSize : originalSize + 1);</span></span><br><span class="line"><span class="comment">//    VVI extendedMatrix(newSize, VI(newSize, 0));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; originalSize; ++i)</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; originalSize; ++j)</span></span><br><span class="line"><span class="comment">//            extendedMatrix[i][j] = A[i][j];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    return extendedMatrix;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 截取矩阵大小到原始大小</span></span><br><span class="line"><span class="comment">//vector&lt;vector&lt;int&gt;&gt; truncateMatrix(const vector&lt;vector&lt;int&gt;&gt;&amp; A, int originalSize) &#123;</span></span><br><span class="line"><span class="comment">//    vector&lt;vector&lt;int&gt;&gt; truncatedMatrix(originalSize, vector&lt;int&gt;(originalSize, 0));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; originalSize; ++i)</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; originalSize; ++j)</span></span><br><span class="line"><span class="comment">//            truncatedMatrix[i][j] = A[i][j];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    return truncatedMatrix;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵加法A+B</span></span><br><span class="line"><span class="function">VVI <span class="title">matrixAdd</span><span class="params">(<span class="type">const</span> VVI&amp; A, <span class="type">const</span> VVI&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">VVI <span class="title">result</span><span class="params">(n, VI(n, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            result[i][j] = A[i][j] + B[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//矩阵减法A-B</span></span><br><span class="line"><span class="function">VVI <span class="title">matrixSubtract</span><span class="params">( <span class="type">const</span> VVI&amp; A, <span class="type">const</span> VVI&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">VVI <span class="title">result</span><span class="params">(n, VI(n, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            result[i][j] = A[i][j] - B[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//矩阵乘法</span></span><br><span class="line"><span class="function">VVI <span class="title">matrixMultiply</span><span class="params">(<span class="type">const</span> VVI&amp; A, <span class="type">const</span> VVI&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">VVI <span class="title">result</span><span class="params">(n, VI(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span> ; k &lt; n; k++)</span><br><span class="line">                result[i][j] += A[i][k] * B[k][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Strassen算法</span></span><br><span class="line"><span class="function">VVI <span class="title">strassen</span><span class="params">(VVI A, VVI B)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">VVI <span class="title">result</span><span class="params">(n, VI(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        result = <span class="built_in">matrixMultiply</span>(A, B);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将矩阵分割成四个子矩阵</span></span><br><span class="line">    <span class="type">int</span> newSize = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">VVI <span class="title">A11</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">A12</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">A21</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">A22</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">VVI <span class="title">B11</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">B12</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">B21</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">B22</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原始矩阵拆分成四个子矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; newSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; newSize; ++j) &#123;</span><br><span class="line">            A11[i][j] = A[i][j];</span><br><span class="line">            A12[i][j] = A[i][j + newSize];</span><br><span class="line">            A21[i][j] = A[i + newSize][j];</span><br><span class="line">            A22[i][j] = A[i + newSize][j + newSize];</span><br><span class="line"></span><br><span class="line">            B11[i][j] = B[i][j];</span><br><span class="line">            B12[i][j] = B[i][j + newSize];</span><br><span class="line">            B21[i][j] = B[i + newSize][j];</span><br><span class="line">            B22[i][j] = B[i + newSize][j + newSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">VVI <span class="title">S1</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S2</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S3</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S4</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S5</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S6</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S7</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S8</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S9</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">VVI <span class="title">S10</span><span class="params">(newSize, VI(newSize, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用加减法计算这10个过程矩阵</span></span><br><span class="line"></span><br><span class="line">    S1 = <span class="built_in">matrixSubtract</span>(A12, A22);</span><br><span class="line">    S2 = <span class="built_in">matrixAdd</span>( B21, B22);</span><br><span class="line">    S3 = <span class="built_in">matrixAdd</span>( A11, A22);</span><br><span class="line">    S4 = <span class="built_in">matrixAdd</span>(B11, B22);</span><br><span class="line">    S5 = <span class="built_in">matrixSubtract</span>( A11, A21);</span><br><span class="line">    S6 = <span class="built_in">matrixAdd</span>( B11, B12);</span><br><span class="line">    S7 = <span class="built_in">matrixAdd</span>(A11, A12);</span><br><span class="line">    S8 = <span class="built_in">matrixSubtract</span>( B12, B22);</span><br><span class="line">    S9 = <span class="built_in">matrixSubtract</span>( B21, B11);</span><br><span class="line">    S10 = <span class="built_in">matrixAdd</span>(A21, A22);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算7次乘法</span></span><br><span class="line"></span><br><span class="line">    VVI M1 = <span class="built_in">strassen</span>(S1, S2);</span><br><span class="line">    VVI M2 = <span class="built_in">strassen</span>(S3, S4);</span><br><span class="line">    VVI M3 = <span class="built_in">strassen</span>(S5, S6);</span><br><span class="line">    VVI M4 = <span class="built_in">strassen</span>(S7, B22);</span><br><span class="line">    VVI M5 = <span class="built_in">strassen</span>(A11, S8);</span><br><span class="line">    VVI M6 = <span class="built_in">strassen</span>(A22, S9);</span><br><span class="line">    VVI M7 = <span class="built_in">strassen</span>(S10, B11);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线性组合乘积矩阵</span></span><br><span class="line">    VVI C11 = <span class="built_in">matrixAdd</span>(M1, M2);</span><br><span class="line">    C11 = <span class="built_in">matrixSubtract</span>(C11, M4);</span><br><span class="line">    C11 = <span class="built_in">matrixAdd</span>(C11, M6);</span><br><span class="line"></span><br><span class="line">    VVI C12 = <span class="built_in">matrixAdd</span>(M4, M5);</span><br><span class="line">    VVI C21 = <span class="built_in">matrixAdd</span>(M6, M7);</span><br><span class="line"></span><br><span class="line">    VVI C22 = <span class="built_in">matrixSubtract</span>(M2, M3);</span><br><span class="line">    C22 = <span class="built_in">matrixAdd</span>(C22, M5);</span><br><span class="line">    C22 = <span class="built_in">matrixSubtract</span>(C22, M7);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建结果矩阵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; newSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; newSize; ++j) &#123;</span><br><span class="line">            result[i][j] = C11[i][j];</span><br><span class="line">            result[i][j + newSize] = C12[i][j];</span><br><span class="line">            result[i + newSize][j] = C21[i][j];</span><br><span class="line">            result[i + newSize][j + newSize] = C22[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow_2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>) <span class="keyword">return</span> n;<span class="comment">//等于零说明只有一个1，即最高位为1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ((n &amp; (n - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//将n转化2的倍数</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        N = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        N = <span class="built_in">pow_2</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成1000阶方阵 a 和 b</span></span><br><span class="line">    <span class="function">VVI <span class="title">a</span><span class="params">(N, VI(N))</span>, <span class="title">b</span><span class="params">(N, VI(N))</span>, <span class="title">c</span><span class="params">(N, VI(N))</span>, <span class="title">result</span><span class="params">(N, VI(N))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            a[i][j] = <span class="built_in">rand</span>() % <span class="number">100</span>; <span class="comment">// 生成范围为 0 到 99 的随机数</span></span><br><span class="line">            b[i][j] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line"><span class="comment">//            if (i == N || j == N) a[i][j] = b[i][j] = 0;//补零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    //初始化二维向量</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">//            cin &gt;&gt; a[i][j];</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">//            cin &gt;&gt; b[i][j];</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    cout &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        puts(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; b[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        puts(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> <span class="type">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="comment">//朴素乘法，时间复杂度为O(n^3)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                c[i][j] += a[i][k] * b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    puts(&quot;&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; c[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     Strassen算法：</span></span><br><span class="line"><span class="comment">      对任意两个2*n阶的矩阵a和b相乘（不足偶数阶的矩阵可以补零扩展），可以将它们各划分为4个小矩阵</span></span><br><span class="line"><span class="comment">      然后将这8个矩阵使用特定的算法求7次乘积，最后将7个临时矩阵M通过加减组合得到最后的第8个结果矩阵</span></span><br><span class="line"><span class="comment">      再将这8个结果矩阵组合为目标矩阵c。</span></span><br><span class="line"><span class="comment">      优点：只有7次乘法，时间复杂度降低为O(n^2.7)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">clock_t</span> <span class="type">tmp_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">    result = <span class="built_in">strassen</span>(a, b);</span><br><span class="line">    <span class="type">clock_t</span> <span class="type">end_t</span> = <span class="built_in">clock</span>();</span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">////            if (i &gt; n - 1 || j &gt; n - 1) continue;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; result[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    puts(&quot;&quot;);</span></span><br><span class="line">    <span class="type">double</span> time1 = (<span class="type">double</span>)(<span class="type">tmp_t</span> - <span class="type">start_t</span>) / CLOCKS_PER_SEC * <span class="number">1000</span>;</span><br><span class="line">    <span class="type">double</span> time2 = (<span class="type">double</span>)(<span class="type">end_t</span> - <span class="type">tmp_t</span>) / CLOCKS_PER_SEC * <span class="number">1000</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;朴素解法耗时为&quot;</span> &lt;&lt; (time1) &lt;&lt; <span class="string">&quot;ms\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;strassen分治法耗时为&quot;</span> &lt;&lt; (time2) &lt;&lt; <span class="string">&quot;ms&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="第-k-小元素分治法">第 K 小元素（分治法）</h1><h2 id="题目大意-2">题目大意</h2><p>给定一个长度为 <span class="math inline">\(n\)</span>的整数序列，找出其中第 <span class="math inline">\(k\)</span>小的元素。要求运用分治法思想，编写程序实现该功能，并对算法的正确性、时间复杂度和空间复杂度进行分析，通过实验测试验证算法。</p><h2 id="解法描述-2">解法描述</h2><ol type="1"><li><strong>算法思想</strong>：借鉴快速排序的分区思想，将序列划分为两部分。通过不断递归，在合适的子序列中查找第<span class="math inline">\(k\)</span> 小的元素。对于长度较小（小于等于5）的子序列，直接排序后获取第 <span class="math inline">\(k\)</span>小元素；对于长度大于 5 的子序列，先划分为多个大小为 5的子序列，找到这些子序列中位数的中位数作为分界点，根据分界点与<spanclass="math inline">\(k\)</span>的关系，确定下一步搜索的子序列。</li><li><strong>实现方式</strong>：程序中，<code>paration</code>函数实现类似快速排序的分区操作，以给定元素<code>k</code>（这里是中位数）为基准，将数组分为两部分，使得左边元素小于<code>k</code>，右边元素大于<code>k</code>，并返回分界点位置。<code>select</code>函数用于递归查找第<spanclass="math inline">\(k\)</span>小的元素，当子序列长度小于等于 5时，直接排序返回第<spanclass="math inline">\(k\)</span>小元素；否则，将子序列划分为大小为 5的子序列，排序后将中位数置于数组前部分，递归找到中位数的中位数<code>x</code>，以 <code>x</code>为基准分区，根据 <code>k</code>与分区点位置的关系，在左半部分或右半部分继续递归查找。</li><li><strong>复杂度分析</strong>：<ul><li><strong>时间复杂度</strong>：每次递归都能将搜索范围缩小，虽然每次递归处理的子序列规模不同，但总体上递归深度不超过<span class="math inline">\(\logn\)</span>，且每次分区操作时间复杂度为线性 <spanclass="math inline">\(O(n)\)</span>，所以算法时间复杂度为 <spanclass="math inline">\(O(n)\)</span>。</li><li><strong>空间复杂度</strong>：主要取决于递归调用栈的深度，由于每次递归序列规模减半，递归栈深度为<span class="math inline">\(O(\logn)\)</span>，且没有使用其他额外数据结构，所以空间复杂度为 <spanclass="math inline">\(O(\log n)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], pos, k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">paration</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123; <span class="comment">//快排</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == k) &#123;<span class="comment">//k是中位数</span></span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[l]);<span class="comment">//把这个数放到最左端</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> i = l, j = r + <span class="number">1</span>;<span class="comment">//中位数作为基准，不用排</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++;</span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt; k);</span><br><span class="line">        <span class="keyword">do</span> j--;</span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt; k);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[l], a[j]);<span class="comment">//把中位数放回去，此时j的左边都比a[j]即k要小</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在数组a[l...r]中选择第k小的元素返回</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(a + l, a + r + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a[l + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pos = (r - l + <span class="number">1</span>) / <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//每组排序后，将中位数序列置于整个数组的前部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pos; i++) &#123;<span class="comment">//选取每段的中位数</span></span><br><span class="line">        <span class="type">int</span> s = l + <span class="number">5</span> * i;</span><br><span class="line">        <span class="type">int</span> t = s + <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">sort</span>(a + s, a + t + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(a[l + i], a[s + <span class="number">2</span>]);<span class="comment">//将第i组的中位数放置在原数组的第(l + i)位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i = l;i &lt;= pos;i++) printf(&quot;%d &quot;, a[i]);</span></span><br><span class="line">    <span class="comment">//选取中位数序列的中位数</span></span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">select</span>(a, l, l + pos - <span class="number">1</span>, (pos + <span class="number">1</span>) / <span class="number">2</span>);<span class="comment">//这个select一定进入if判断</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">paration</span>(a, l, r, x);<span class="comment">//x就是中位数的中位数，排列完后可以保证i的左右两侧的元素个数相对一致</span></span><br><span class="line">    <span class="type">int</span> j = i - l + <span class="number">1</span>;<span class="comment">//计算此时区间长度</span></span><br><span class="line">    <span class="keyword">if</span> (k == j) <span class="keyword">return</span> a[i];<span class="comment">//因为在if中已经sort了，所以直接就是有序的</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; j) <span class="keyword">return</span> <span class="built_in">select</span>(a, l, i, k);<span class="comment">//对左段排序</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">select</span>(a, i + <span class="number">1</span>, r, k - j);<span class="comment">//对右段排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">select</span>(a, <span class="number">1</span>, n, k));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法设计与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析-第一章</title>
      <link href="/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2025/03/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<ul><li>推销员问题 <ahref="https://www.luogu.com.cn/record/149769403">记录详情 - 洛谷 |计算机科学教育新生态</a></li><li>骑士周游列国 <ahref="https://www.luogu.com.cn/record/149592866">记录详情 - 洛谷 |计算机科学教育新生态</a></li><li>码头扩建</li><li>算法时间复杂度分析</li></ul><span id="more"></span><h1 id="推销员问题tsp">推销员问题（TSP）</h1><h2 id="题目大意">题目大意</h2><p>推销员问题（Traveling SalesmanProblem，TSP）是一个经典的组合优化问题。在该问题中，一个推销员需要访问一系列城市，每个城市只能访问一次，最后必须回到起始城市，目标是找到一条总路径长度最短的路线。从图论角度看，可将城市视为图的节点，城市之间的路径视为图的边，边的权重表示城市间的距离，问题等价于在完全图中寻找<strong>最小权重的哈密尔顿回路</strong>。</p><h2 id="解法描述">解法描述</h2><h3 id="朴素穷举剪枝优化">朴素穷举+剪枝优化</h3><ol type="1"><li><strong>算法思想</strong>：通过枚举所有可能的城市访问顺序，计算每种顺序下的路径总长度，从而找出最短路径。利用贪心法进行剪枝，在枚举过程中，如果当前路径长度已经大于已知的最小路径长度，停止对该路径后续情况的枚举。</li><li><strong>实现方式</strong>：在 C++中，借助<code>next_permutation</code>函数来枚举所有城市排列。对每个排列，依次计算相邻城市间的距离并累加，得到该排列对应的路径长度。在计算过程中，一旦路径长度超过当前记录的最小路径长度，直接放弃该排列的后续计算。</li><li><strong>复杂度分析</strong><ul><li><strong>时间复杂度</strong>：朴素穷举的时间复杂度为<spanclass="math inline">\(O(n!)\)</span>，因为需要枚举<spanclass="math inline">\(n\)</span>个城市的所有排列。虽然剪枝优化在一定程度上减少了不必要的计算，但在最坏情况下，时间复杂度仍然是<spanclass="math inline">\(O(n!)\)</span>。当城市数量<spanclass="math inline">\(n\)</span>较大时，计算量会急剧增加，导致算法效率极低。</li><li><strong>空间复杂度</strong>：主要取决于存储每个排列的空间，由于只需要存储一个城市排列序列，所以空间复杂度为<spanclass="math inline">\(O(n)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 朴素解，用next_permutation函数枚举所有城市排列，在所有可能的路径长度中取最小的。最坏时间复杂度为O(n!)</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; cities;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>; <span class="comment">// 视为无穷大</span></span><br><span class="line"><span class="type">int</span> n, final_ans = INF, x; <span class="comment">// 城市数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">ans += g[path[i]][path[i + <span class="number">1</span>]]; <span class="comment">// 从第i个城市到第i+1个城市</span></span><br><span class="line"><span class="keyword">if</span> (ans &gt; final_ans) &#123;</span><br><span class="line"><span class="keyword">return</span> final_ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve_TSP</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cities</span><span class="params">(n)</span></span>;<span class="comment">// 城市遍历序列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cities[i] = i;<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="built_in">compute</span>(cities);</span><br><span class="line">final_ans = <span class="built_in">min</span>(final_ans, tmp);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(cities.<span class="built_in">begin</span>() + <span class="number">1</span>, cities.<span class="built_in">end</span>())); <span class="comment">// 用next_permut交换各个城市的相对位置</span></span><br><span class="line"><span class="keyword">return</span> final_ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">g.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">-1</span>) x = INF;</span><br><span class="line">g[i][j] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">solve_TSP</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划法bellman---held---karp-算法">动态规划法（Bellman - Held- Karp 算法）</h3><ol type="1"><li><strong>算法思想</strong>：将原问题划分为多个子问题，通过求解子问题的最优解，逐步构建出原问题的最优解。把所有可能的路径用二进制序列表示，其中1 表示对应城市已走过，0表示未走过。利用状态转移方程，根据已走过城市的状态和当前所在城市，计算出走到下一个未走过城市的最小消耗。<em>本做法是<a href="https://www.luogu.com.cn/problem/P1171">P1171 售货员的难题 -洛谷</a> 的正解。</em></li><li><strong>实现方式</strong>：定义两个二维数组 <code>dp</code> 和<code>path</code>，<code>dp[i][j]</code> 表示当前走过的城市状态为<code>i</code> （二进制表示）且当前位于城市 <code>j</code>时的最小消耗；<code>path[i][j]</code> 记录走到城市 <code>j</code>（状态为 <code>i</code>时）的前一个城市。通过三层循环，外层循环遍历所有可能的城市状态（从 <spanclass="math inline">\(1\)</span> 到 <span class="math inline">\(2^n -1\)</span>），中层循环在当前状态下遍历所有城市找到已走过的城市<code>u</code>，内层循环遍历所有城市找到未走过的城市<code>v</code>，更新 <code>dp</code> 数组和 <code>path</code>数组。最后，通过遍历所有城市，找到从所有城市回到起始城市的最小路径长度，并根据<code>path</code> 数组回溯出具体路径。</li><li><strong>复杂度分析</strong><ul><li><strong>时间复杂度</strong>：算法中有三层循环，外层循环遍历<spanclass="math inline">\(2^n\)</span>种城市状态，中层和内层循环分别遍历<spanclass="math inline">\(n\)</span>个城市，所以时间复杂度为<spanclass="math inline">\(O(n^2\times2^n)\)</span>。尽管它仍然是指数级复杂度，但相比朴素穷举的<spanclass="math inline">\(O(n!)\)</span>，在实际计算中，由于利用了子问题的重叠性质，减少了重复计算，通常能在更短时间内找到最优解。</li><li><strong>空间复杂度</strong>：主要由存储子问题最优解的二维数组<code>dp</code> 和 <code>path</code> 决定，它们的大小都是<spanclass="math inline">\((2^n)\times n\)</span>，所以空间复杂度为<spanclass="math inline">\(O(n\times2^n)\)</span>。当<spanclass="math inline">\(n\)</span>较大时，可能会面临内存不足的问题。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用Bellman-Held-Karp算法，时间复杂度O((2^n)*(n^2))</span></span><br><span class="line"><span class="comment">  开两个vector&lt;vector&lt;int&gt;, int&gt;数组，大小为(2^n)*n，以空间换时间</span></span><br><span class="line"><span class="comment">  本算法将所有的可能路径视为二进制序列，1为已经走过，0为未走过。</span></span><br><span class="line"><span class="comment">  不难发现，n个城市一共有2^n种序列，因此遍历他们总共需要2^n次</span></span><br><span class="line"><span class="comment">  同时在每次选取了一个序列后，还需要用双重循环来：1.在已经走过的路径中选择一个出发点 2.选择接下来要走的点（不能已经在集合中），增加将边权加入dist</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//可以处理n=23的问题，并且耗时较少。但是n更大会导致无法分配足够内存而报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> final_ans, n, start_idx;</span><br><span class="line"><span class="comment">//void init() &#123;</span></span><br><span class="line"><span class="comment">////用assign填充</span></span><br><span class="line"><span class="comment">//g.assign(n, vector&lt;int&gt;(n, INF));</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//for (int j = i + 1; j &lt; n; j++) g[i][j] = g[j][i] = rand() % 100 + 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//dp.assign(1 &lt;&lt; n, vector&lt;int&gt;(n, INF));</span></span><br><span class="line"><span class="comment">//path.assign(1 &lt;&lt; n, vector&lt;int&gt;(n, -1));</span></span><br><span class="line"><span class="comment">//start_idx = 0;</span></span><br><span class="line"><span class="comment">//dp[1 &lt;&lt; start_idx][start_idx] = 0; //从0号城市回到0号的距离为0</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bellman_Held_Karp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  dp和path的第一维用于记录当前走过的城市，第二维用于记录本次走到的终点</span></span><br><span class="line"><span class="comment">  dp的值表示走法的最小消耗,path的值表示走终点的前一个点是谁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123; <span class="comment">//遍历2^n-1次，i是十进制表示的二进制序列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123; <span class="comment">//遍历所有点，找到已经在集合中的</span></span><br><span class="line"><span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; u)) &#123; <span class="comment">//1&lt;&lt;u表示二进制序列中第u为是1，用&amp;来判断第u位是否都是1，是则表明点u已经在当前的路径中了</span></span><br><span class="line"><span class="comment">//选取城市u，试图以其为起点走到城市v</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; (<span class="number">1</span> &lt;&lt; v))) &#123; <span class="comment">//如果v还没走过，那就不会形成环路，可以走</span></span><br><span class="line"><span class="keyword">if</span> (dp[i | (<span class="number">1</span> &lt;&lt; v)][v] &gt; dp[i][u] + g[u][v]) &#123;</span><br><span class="line">dp[i | (<span class="number">1</span> &lt;&lt; v)][v]  = (dp[i | (<span class="number">1</span> &lt;&lt; v)][v], dp[i][u] + g[u][v]); <span class="comment">//检测从u走到v是否会使得路径边长，更新路径集合和其对应的值</span></span><br><span class="line">path[i | (<span class="number">1</span> &lt;&lt; v)][v] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加最后构成回环的路径</span></span><br><span class="line"><span class="type">int</span> final_que = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; <span class="comment">//全为1的二进制序列</span></span><br><span class="line">final_ans = INF;</span><br><span class="line"><span class="type">int</span> last_city = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; n; t++) &#123; <span class="comment">//再次遍历所有点</span></span><br><span class="line"><span class="type">int</span> tmp = dp[final_que][t];<span class="comment">//tmp表示走过了所有点后，回到点t</span></span><br><span class="line"><span class="type">int</span> last_w = g[t][start_idx];<span class="comment">//最后一条边的权重</span></span><br><span class="line"><span class="keyword">if</span> (tmp + last_w &lt; final_ans) &#123;</span><br><span class="line">final_ans = tmp + last_w;</span><br><span class="line">last_city = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读出path中存的点作为路径</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path_ans;</span><br><span class="line"><span class="comment">//因为是环路，所以可以从后往前记录</span></span><br><span class="line"><span class="type">int</span> current_city = last_city;</span><br><span class="line"><span class="type">int</span> current_set = final_que;</span><br><span class="line"><span class="keyword">while</span> (current_city != <span class="number">-1</span>) &#123; <span class="comment">//-1是path数组的初始值</span></span><br><span class="line">path_ans.<span class="built_in">push_back</span>(current_city);</span><br><span class="line">current_set ^= (<span class="number">1</span> &lt;&lt; current_city); <span class="comment">//将当前城市从集合中删除</span></span><br><span class="line">current_city = path[current_set | (<span class="number">1</span> &lt;&lt; current_city)][current_city];</span><br><span class="line"><span class="comment">//上一个城市是以这个城市为终点的边的起点，要暂时补回删掉的城市</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;序列表示哈密顿回路&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; start_idx &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : path_ans) &#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_g</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) cout &lt;&lt; g[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="comment">//print_g();</span></span><br><span class="line"><span class="comment">//clock_t start_t = clock();</span></span><br><span class="line"><span class="built_in">Bellman_Held_Karp</span>();</span><br><span class="line"><span class="comment">//clock_t end_t = clock();</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;最短路径权值为&quot; &lt;&lt; final_ans &lt;&lt; endl;</span></span><br><span class="line">cout &lt;&lt; final_ans &lt;&lt; endl;</span><br><span class="line"><span class="comment">//double elapsed_time = (double)(end_t - start_t) / CLOCKS_PER_SEC;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;耗时为&quot; &lt;&lt; (elapsed_time) &lt;&lt; &quot;s&quot;;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="骑士周游列国">骑士周游列国</h1><h2 id="题目大意-1">题目大意</h2><p>在国际象棋 8×8 的棋盘上，给定骑士的初始位置(<spanclass="math inline">\(m\)</span>,<spanclass="math inline">\(n\)</span>)（其中 <spanclass="math inline">\(0\leq m,n\leq 8\)</span>），要求找出一条路径，使骑士不重不漏地经过棋盘上的每一个格子。路径需用8×8的矩阵输出，矩阵中每个元素的值表示骑士到达该位置时行走的步数，起始位置步数为1。</p><h2 id="解法描述-1">解法描述</h2><h3 id="深度优先遍历-dfs">深度优先遍历 DFS</h3><ol type="1"><li><strong>算法思想</strong>：深度优先搜索是一种“试错”的搜索策略。从起始位置开始，按照骑士的移动规则，尝试所有可能的走法。若当前走法能继续推进（新位置未被访问过），则标记该位置并递归继续探索；若当前位置的所有走法都无法推进（新位置已被访问或越界），则回溯到上一个位置，尝试其他未探索的走法，直至遍历完整个棋盘或确定不存在可行路径。</li><li><strong>实现方式</strong>：使用一个二维数组 <code>g[N][N]</code>表示棋盘，其中 <code>N = 8</code>。数组元素值为 0 表示该位置未被访问，非0 值表示骑士到达该位置的步数。定义方向数组 <code>dx[8]</code> 和<code>dy[8]</code> 来表示骑士的 8 种移动方向。在 <code>dfs</code>函数中，每次递归时检查当前位置的 8个可能移动方向，若新位置合法且未被访问，则标记新位置并递归调用<code>dfs</code> 继续探索，若递归返回 <code>true</code>说明找到了可行路径，直接返回；若所有方向都尝试完仍未找到可行路径，则回溯（将新位置标记回0）并返回<code>false</code>。在主函数中，读入起始位置，初始化起始位置的步数为1，调用 <code>dfs</code>函数进行搜索，若找到路径则输出棋盘矩阵，否则输出提示信息。</li><li><strong>复杂度分析</strong>：<ul><li><strong>时间复杂度</strong>：在最坏情况下，每个位置都要尝试 8种走法，对于 8×8 的棋盘，共有 64个位置。随着搜索的深入，分支数量呈指数增长，所以时间复杂度约为 <spanclass="math inline">\(O(8^{64})\)</span>，这是一个非常高的时间复杂度，意味着在大规模问题下，算法效率极低。</li><li><strong>空间复杂度</strong>：空间复杂度主要取决于递归调用栈的深度。因为在最坏情况下需要遍历整个棋盘，而每次递归调用都会在栈中占用一定空间，递归深度最大为64，所以空间复杂度为 <span class="math inline">\(O(N^{2})\)</span>，即<span class="math inline">\(O(64)\)</span> 。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  本题需要在8*8棋盘中，从一个点出发找到遍历所有点的一条路径</span></span><br><span class="line"><span class="comment">  关键点：每个点都有8种可能的走法，但是最终只需要找到一条可以遍历所有点的路径</span></span><br><span class="line"><span class="comment">  因此采用dfs递归搜索，并增加返回值以表示当前所走的方向是否正确，确保在找到一条正确路径后就结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, step;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; N &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> step)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (step &gt; <span class="number">64</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 找到路径后返回 true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> tx = x + dx[i], ty = y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(tx, ty) &amp;&amp; g[tx][ty] == <span class="number">0</span>) &#123;</span><br><span class="line">g[tx][ty] = step;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(tx, ty, step + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//如果是合适的路径，那就不需要回溯</span></span><br><span class="line"><span class="keyword">else</span> g[tx][ty] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">g[n][m] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(n, m, <span class="number">2</span>)) &#123;</span><br><span class="line"><span class="comment">// 如果找到路径，输出路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">cout &lt;&lt; g[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No solution found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启发式搜索-warnsdorff-规则">启发式搜索 Warnsdorff 规则</h3><ol type="1"><li><strong>算法思想</strong>：Warnsdorff规则是一种启发式策略，其核心是在当前位置选择一阶落点时，优先考察各个一阶落点的可行二阶落点个数，选择可行二阶落点个数最少的一阶落点作为下一步移动方向。这样做的目的是优先选择那些周围“出路”较少的位置，使搜索更有针对性，减少不必要的回溯，提高搜索效率。</li><li><strong>实现方式</strong>：在原 DFS 代码基础上进行修改。定义一个函数<code>get_weight</code>来计算某个位置的可行二阶落点个数。在每次选择下一步移动位置时，将所有可行的一阶落点及其权重（可行二阶落点个数）存入一个向量<code>v</code> 中，然后对向量 <code>v</code>按权重从小到大排序。优先尝试权重小的落点进行递归搜索，若找到可行路径则返回，否则回溯继续尝试其他落点。</li><li><strong>复杂度分析</strong>：<ul><li><strong>时间复杂度</strong>：在最坏情况下，检查每个位置的邻居时，需要考虑所有可能的移动位置，这里邻居个数<span class="math inline">\(N = 8\)</span>，时间复杂度为 <spanclass="math inline">\(O(N^{2})\)</span>，即 <spanclass="math inline">\(O(8^{2}) = O(64)\)</span>。但实际上，由于Warnsdorff规则的引导，搜索过程会优先选择更有可能成功的路径，大幅减少了搜索范围，基本可在线性时间内检测完棋盘上的所有点，相比朴素DFS 的指数级复杂度有显著优化。</li><li><strong>空间复杂度</strong>：空间复杂度与 DFS类似，主要取决于递归深度或栈的大小。在最坏情况下，同样为 <spanclass="math inline">\(O(N^{2})\)</span> （<spanclass="math inline">\(N\)</span> 是棋盘边长），即 <spanclass="math inline">\(O(64)\)</span>。不过，由于 Warnsdorff规则的引导，搜索路径从八叉树退化为二叉树，使得递归深度降低。虽然这对空间复杂度的理论影响不大，但在实际运行中，对于只需求一个可行解的情况，实际空间利用效率更高，减少了不必要的空间占用。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Warnsdorff规则：</span></span><br><span class="line"><span class="comment">  在当前位置(x,y)选择一阶落点时，先考察各个一阶落点的可行二阶落点个数，选择其中可行二阶落点个数最少一阶落点（以下暂记这个一阶落点为可行方向）</span></span><br><span class="line"><span class="comment">  有效性分析：</span></span><br><span class="line"><span class="comment">  本规则要求每次选择可行方向，不难发现，在周游初期，这个方向一定是存在的。而在后期，如果能完成一次巡游，那么可行方向也必须存在。</span></span><br><span class="line"><span class="comment">  因此可行方向一定可以构成一个正确回路（当然正确回路不一定是由可行方向组成的），由于本题只需要一个解，所以该规则有效</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  综上，在得知Warnsdorff规则后，我们就可以对dfs进行剪枝了，以每个一阶落点的二级落点个数作为权值，从而可以将原来的满8分叉树化简为二叉或三叉树，从而更快地找到一个答案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, PII&gt; PIPII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> g[N][N], x, y;</span><br><span class="line">PII direc[N] = &#123; &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; N &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; N &amp;&amp; g[x][y] == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_g</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">cout &lt;&lt; g[i][j] &lt;&lt; <span class="string">&quot; \n&quot;</span>[j == N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_weight</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tx, ty, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">tx = x + direc[i].x, ty = y + direc[i].y;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ok</span>(tx, ty)) res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> step)</span> </span>&#123; <span class="comment">//设置为bool类型以期在找到答案的第一时间结束递归</span></span><br><span class="line"><span class="keyword">if</span> (step == <span class="number">65</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> tx, ty;</span><br><span class="line">vector&lt;PIPII&gt; v;<span class="comment">//存放本次检测的所有一阶落点和他们的权重</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">tx = x + direc[i].x, ty = y + direc[i].y;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ok</span>(tx, ty))v.<span class="built_in">push_back</span>(&#123;<span class="built_in">get_weight</span>(tx, ty), &#123;tx, ty&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> t : v) &#123;</span><br><span class="line">g[t.y.x][t.y.y] = step;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(t.y.x, t.y.y, step + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">g[t.y.x][t.y.y] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">g[x][y] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x, y, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">print_g</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种可能的周游路径如下： <img src="img.png" title="img"alt="img" /></p><h1 id="码头扩建问题">码头扩建问题</h1><h2 id="题目大意-2">题目大意</h2><p>某市有一码头，每次仅允许一艘船停泊装卸货。根据历史资料，码头平均每月停船24 艘，每艘船的停泊时间为 24±20 小时，相邻两艘船的到达时间间隔为 30±15小时。若一艘船因有其他船在港而等候 1 小时，其消耗成本为 1000元。扩建码头大约需要 1350万元。要求通过程序随机产生到达时间和停泊时间，模拟未来五年内船的停泊情况，多次模拟预测停泊情况，以判断未来五年内停泊船只因等候的成本消耗总和是否超过扩建码头花费，从而帮助市长做出是否扩建码头的决策。</p><h2 id="解法描述-2">解法描述</h2><h3 id="离散事件模拟算法">离散事件模拟算法</h3><ol type="1"><li><strong>算法思想</strong>：利用离散事件模拟的方法，将未来五年的时间按月划分，通过循环模拟每个月内船只的到达和停泊过程。在模拟过程中，借助随机数生成符合条件的船只到达时间间隔和停泊时间，根据船只到达时码头的状态（是否有船正在停泊）来计算等待时间和成本，最后累加所有模拟次数的成本并求平均，与扩建码头的成本阈值进行比较，得出是否扩建的结论。</li><li><strong>实现方式</strong>：在 C++中，使用<code>&lt;random&gt;</code> 库生成随机数。<code>random_device rd</code>用于生成随机数种子，<code>mt19937 gen(rd())</code>创建一个基于种子的随机数生成器。通过两层嵌套循环进行模拟，外层循环控制模拟的总次数（如1000 次），内层循环模拟每个月（共 60个月）的情况。对于每个月，假设第一艘船在最开始到达，生成其停泊时间。后续船只根据上一艘船的到达和停泊时间计算自身到达时间，若到达时上一艘船还在停靠，则计算等待成本，更新停泊时间；若无需等待，则直接更新停泊时间。每次模拟结束后累加总成本，最后根据总成本与扩建成本阈值的比较结果输出决策信息。</li><li><strong>复杂度分析</strong>：<ul><li><strong>时间复杂度</strong>：外层循环执行次数为模拟总次数，设为<code>test</code>，时间复杂度为 <spanclass="math inline">\(O(test)\)</span>。内层循环执行 60次，内层循环中的计算操作，如随机数生成、条件判断和成本计算等，都是常数时间操作，时间复杂度为<span class="math inline">\(O(1)\)</span>。所以总体时间复杂度为 <spanclass="math inline">\(O(test×1)\)</span>，即 <spanclass="math inline">\(O(test)\)</span>。当模拟次数增加时，运行时间会线性增长。</li><li><strong>空间复杂度</strong>：程序中主要使用了几个整型变量（如<code>spend</code>、<code>dock_time</code>、<code>arrival_time</code>等）和一个长整型变量（<code>cost</code>）来存储数据，这些变量占用的存储空间是常数级别的。随机数生成器的存储空间与生成器的状态大小相关，但在本实验中，其状态大小也是常数级别的，不会对空间复杂度产生显著影响。因此，总体空间复杂度为<span class="math inline">\(O(1)\)</span>，即无论模拟次数和数据规模如何变化，程序占用的空间基本保持不变。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  为了简化情况，本模拟将五年按月划分开，即以一个月为基础编写代码，并循环5*12次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span>  Max = <span class="number">1.35e7</span>;</span><br><span class="line"><span class="type">int</span> spend, pre = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> dock_time, arrival_time;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cost, tmp_cost;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line">random_device rd;<span class="comment">//声名一个随机数种子对象。命名为rd</span></span><br><span class="line"><span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;<span class="comment">//创建了一个 mt19937 类的对象，它使用前面声明的 rd 对象生成的种子进行构造。这个对象被命名为 gen。</span></span><br><span class="line"><span class="comment">//uniform_int_distribution&lt;&gt;，均匀分布的随机数生成器</span></span><br><span class="line"><span class="comment">//下述的arrival_interval和docking_time是一个类，接受gen作为参数</span></span><br><span class="line">uniform_int_distribution&lt;&gt; <span class="built_in">arrival_interval</span>(<span class="number">15</span>, <span class="number">45</span>);<span class="comment">//到达时间</span></span><br><span class="line">uniform_int_distribution&lt;&gt; <span class="built_in">docking_time</span>(<span class="number">4</span>, <span class="number">44</span>);<span class="comment">//停泊时间</span></span><br><span class="line"><span class="comment">//进行一千次模拟</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= <span class="number">1000</span>; t++) &#123;</span><br><span class="line">tmp_cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> month = <span class="number">1</span>; month &lt;= <span class="number">60</span>; month++) &#123;</span><br><span class="line"><span class="comment">//不考虑从月末停留到月初的情况</span></span><br><span class="line"><span class="comment">//不妨假设第一艘船是在最开始到达的</span></span><br><span class="line">dock_time = arrival_time = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ship = <span class="number">1</span>; ship &lt;= <span class="number">24</span>; ship++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ship == <span class="number">1</span>) &#123;</span><br><span class="line">dock_time = <span class="built_in">docking_time</span>(gen);<span class="comment">//开始卸货</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//本船到达</span></span><br><span class="line">arrival_time += <span class="built_in">arrival_interval</span>(gen);<span class="comment">//增加表示间隔时间</span></span><br><span class="line"><span class="keyword">if</span> (arrival_time &lt; dock_time) &#123;</span><br><span class="line"><span class="comment">//到达时上一艘船还在停靠</span></span><br><span class="line"></span><br><span class="line">tmp_cost += (dock_time - arrival_time) * pre;</span><br><span class="line">dock_time += <span class="built_in">docking_time</span>(gen); <span class="comment">//本船还不能进港操作，必须等上一只船结束</span></span><br><span class="line">&#125; <span class="keyword">else</span> dock_time = arrival_time + <span class="built_in">docking_time</span>(gen); <span class="comment">//无需等待，那就是入港时间加自身卸货</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dock_time = docking_time(gen);</span></span><br><span class="line"><span class="comment">//arrival_time = arrival_interval(gen);</span></span><br><span class="line"><span class="comment">//if (dock_time &gt; arrival_time) tmp_cost += 1000 * (dock_time - arrival_time);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cost += tmp_cost / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cost &gt; Max) cout &lt;&lt; <span class="string">&quot;超支了&quot;</span> &lt;&lt; cost - Max &lt;&lt; <span class="string">&quot;元&quot;</span> &lt;&lt; <span class="string">&quot;应该扩建&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;距离超支还有%lld元，不用扩建&quot;</span>, (Max - cost));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法时间复杂度的实验测试">算法时间复杂度的实验测试</h1><h2 id="题目大意-3">题目大意</h2><p>运用编程工具对堆排序或快速排序算法进行时间复杂度测试，通过在不同输入规模下运行算法并记录运行时间，从而学会通过实验分析算法的时间复杂度。</p><h2 id="解法描述-3">解法描述</h2><h3 id="堆排序算法">堆排序算法</h3><ol type="1"><li><strong>算法思想</strong>：基于二叉堆数据结构，以构建大根堆为例实现从小到大排序。首先将输入数组进行堆化操作，使每个节点都满足大根堆性质，即父节点的值大于等于子节点的值。然后不断将堆顶元素（最大值）与数组末尾元素交换，将最大值放到数组末尾，接着对交换后的堆进行调整，维持堆的性质，重复该过程直到整个数组有序。</li><li><strong>实现方式</strong>：在 C++代码中，定义数组<code>heap[N]</code> 存储待排序数据，<code>N</code>为数组最大容量。<code>down</code>函数用于调整堆，在函数中，通过比较当前节点与其左右子节点的值，将最大值交换到当前节点位置，并递归向下调整。在<code>main</code> 函数中，利用 <code>&lt;random&gt;</code>库生成随机数填充数组。排序前使用 <code>clock()</code>函数记录起始时间，排序过程先对数组进行堆化（从 <code>n/2</code> 到<code>0</code> 调用 <code>down</code>函数），然后通过不断交换堆顶和末尾元素并调整堆（共 <code>n</code>次）实现排序。排序结束后再次使用 <code>clock()</code>函数记录结束时间，计算并输出排序耗时。</li><li><strong>复杂度分析</strong>：<ul><li><strong>时间复杂度</strong>：堆排序的时间复杂度为 <spanclass="math inline">\(O(n log n)\)</span>。堆构建阶段，从<code>n/2</code> 到 <code>0</code> 调用 <code>down</code>函数，每次调整操作的时间复杂度为 <span class="math inline">\(O(logn)\)</span>，总共进行约 <span class="math inline">\(n/2\)</span>次，时间复杂度为 <span class="math inline">\(O(n log n)\)</span>；排序阶段，进行 <code>n</code>次交换和调整堆操作，每次调整堆的时间复杂度也是 <spanclass="math inline">\(O(log n)\)</span>，整体排序阶段时间复杂度同样为<span class="math inline">\(O(n log n)\)</span>。</li><li><strong>空间复杂度</strong>：堆排序仅使用了常数级别的额外空间，如在调整堆过程中临时变量的存储，因此空间复杂度为<span class="math inline">\(O(1)\)</span>。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> heap[N];<span class="comment">//大根堆实现从小到大排列</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = idx;</span><br><span class="line"><span class="comment">//大根堆的根应该是最大的</span></span><br><span class="line"><span class="comment">//在idx，2*idx+1，2*idx三者中找到值最大的那一个</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> * idx &lt;= n &amp;&amp; heap[tmp] &lt; heap[idx * <span class="number">2</span>]) tmp = idx * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> * idx + <span class="number">1</span> &lt;= n &amp;&amp; heap[tmp] &lt; heap[idx * <span class="number">2</span> + <span class="number">1</span>]) tmp = idx * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp != idx) &#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[idx], heap[tmp]);<span class="comment">//让最大值来到根的位置</span></span><br><span class="line"><span class="built_in">down</span>(tmp);<span class="comment">//递归向下交换，使小的值向下，大的值向上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成随机数构造器</span></span><br><span class="line">random_device rd;<span class="comment">//声名一个随机数种子对象。命名为rd</span></span><br><span class="line"><span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;<span class="comment">//创建了一个 mt19937 类的对象，它使用前面声明的 rd 对象生成的种子进行构造。这个对象被命名为 gen。</span></span><br><span class="line">uniform_int_distribution&lt;&gt; <span class="built_in">random_num</span>(<span class="number">0</span>, <span class="number">10000000</span>);<span class="comment">//均匀分布的随机数</span></span><br><span class="line"><span class="comment">//填充随机数</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="comment">//从一开始存避免找子节点时找到自己</span></span><br><span class="line">heap[i] = <span class="built_in">random_num</span>(gen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序开始</span></span><br><span class="line"><span class="type">clock_t</span> <span class="type">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="built_in">down</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[<span class="number">1</span>], heap[n]);<span class="comment">//交换n次，将大值放在尾部，相当于从堆里剔除</span></span><br><span class="line">n--;</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">clock_t</span> <span class="type">end_t</span> = <span class="built_in">clock</span>();</span><br><span class="line"><span class="type">double</span> elapsed_time = (<span class="type">double</span>)(<span class="type">end_t</span> - <span class="type">start_t</span>) / CLOCKS_PER_SEC * <span class="number">1000</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;耗时为&quot;</span> &lt;&lt; (elapsed_time) &lt;&lt; <span class="string">&quot;ms&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序算法">快速排序算法</h3><ol type="1"><li><strong>算法思想</strong>：采用分治策略。选择一个基准元素，将数组分为两个子数组，使得左边子数组的元素都小于基准元素，右边子数组的元素都大于基准元素。然后递归地对左右子数组进行排序，最后合并各个有序子数组得到最终的有序数组。</li><li><strong>实现方式</strong>：代码中定义数组 <code>q[N]</code>存储数据。<code>quick_sort</code>函数实现快速排序逻辑，函数中先选取一个基准元素（这里取数组中间元素<code>q[(l + r) &gt;&gt; 1]</code>），通过双指针 <code>i</code>和<code>j</code>从数组两端向中间扫描，将小于基准的元素放到左边，大于基准的元素放到右边。当<code>i</code> 和 <code>j</code>相遇时，完成一次划分，接着递归对左右子数组进行排序。在 <code>main</code>函数中，同样利用 <code>&lt;random&gt;</code>库生成随机数填充数组，记录排序前后的时间，计算并输出排序耗时。</li><li><strong>复杂度分析</strong>：<ul><li><strong>时间复杂度</strong>：快速排序平均时间复杂度为 <spanclass="math inline">\(O(n logn)\)</span>。在平均情况下，每次划分都能将数组大致均匀分成两部分，递归深度为<span class="math inline">\(log n\)</span>，每层划分操作的时间复杂度为<span class="math inline">\(O(n)\)</span>，整体时间复杂度为 <spanclass="math inline">\(O(n logn)\)</span>。但在最坏情况下，如每次选取的基准元素都是数组中的最大或最小值，划分会极度不均匀，时间复杂度会退化为<span class="math inline">\(O(n^2)\)</span> 。</li><li><strong>空间复杂度</strong>：快速排序的空间复杂度主要取决于递归调用的栈空间。平均情况下，递归深度为<span class="math inline">\(log n\)</span>，因此空间复杂度为 <spanclass="math inline">\(O(log n)\)</span>；在最坏情况下，递归深度达到<span class="math inline">\(n\)</span>，空间复杂度为 <spanclass="math inline">\(O(n)\)</span> 。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> q[N];<span class="comment">//大根堆实现从小到大排列</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//左右指针相遇</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x = q[(l + r) &gt;&gt; <span class="number">1</span>]; <span class="comment">//随便取一个标定</span></span><br><span class="line"><span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;<span class="comment">//选不可能点</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">do</span> i++;</span><br><span class="line"><span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line"><span class="keyword">do</span> j--;</span><br><span class="line"><span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line"><span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束后[l,j]的数都比x要小，[j+1,r]的数都比x要大</span></span><br><span class="line"><span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成随机数构造器</span></span><br><span class="line">random_device rd;<span class="comment">//声名一个随机数种子对象。命名为rd</span></span><br><span class="line"><span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;<span class="comment">//创建了一个 mt19937 类的对象，它使用前面声明的 rd 对象生成的种子进行构造。这个对象被命名为 gen。</span></span><br><span class="line">uniform_int_distribution&lt;&gt; <span class="built_in">random_num</span>(<span class="number">0</span>, <span class="number">10000000</span>);<span class="comment">//均匀分布的随机数</span></span><br><span class="line"><span class="comment">//填充随机数</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">q[i] = <span class="built_in">random_num</span>(gen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">clock_t</span> <span class="type">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="type">clock_t</span> <span class="type">end_t</span> = <span class="built_in">clock</span>();</span><br><span class="line"><span class="type">double</span> elapsed_time = (<span class="type">double</span>)(<span class="type">end_t</span> - <span class="type">start_t</span>) / CLOCKS_PER_SEC * <span class="number">1000</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;耗时为&quot;</span> &lt;&lt; (elapsed_time) &lt;&lt; <span class="string">&quot;ms&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法设计与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一讲-排序与枚举</title>
      <link href="/2025/02/28/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9E%9A%E4%B8%BE/"/>
      <url>/2025/02/28/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="作业链接">作业链接</h1><p><a href="https://www.luogu.com.cn/training/714006">[蓝桥杯]第一讲：排序与枚举 - 题单 - 洛谷 | 计算机科学教育新生态</a></p><h1 id="ac-代码">AC 代码</h1><span id="more"></span><h2 id="p1177-模板排序---洛谷"><ahref="https://www.luogu.com.cn/problem/P1177">P1177 【模板】排序 -洛谷</a></h2><p>知识点：sort 函数</p><p>学习怎么使用 sort 将数组变为升序有序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+9</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 读取整数n</span></span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 读取n个整数并存储到列表a中</span></span><br><span class="line"></span><br><span class="line">a.sort()  <span class="comment"># 对列表a进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出排序后的结果，每个数字后跟一个空格</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, a)))</span><br></pre></td></tr></table></figure><h2 id="p1271-深基-9.例-1选举学生会---洛谷"><ahref="https://www.luogu.com.cn/problem/P1271">P1271 【深基 9.例1】选举学生会 - 洛谷</a></h2><p>知识点：桶排序</p><p>数组下标本身就是有序的，可以根据值域考虑使用下标来实现有序化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">p[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (p[i]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">p[i]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p10901-蓝桥杯-2024-省-c-封闭图形个数---洛谷"><ahref="https://www.luogu.com.cn/problem/P10901">P10901 [蓝桥杯 2024 省 C]封闭图形个数 - 洛谷</a></h2><p>知识点：自定义排序函数</p><p>基础的 sort 函数只能升序排列，通过手写 cmp函数可以实现自定义的排序方法。cmp 是一种 bool类型的函数，通过比较传入的两个值，保证相邻的 x 和 y符合我们定义的规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> mp[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span><span class="number">+9</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; y)flg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x) &#123;</span><br><span class="line">cnt1 += mp[x % <span class="number">10</span>];</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (y) &#123;</span><br><span class="line">cnt2 += mp[y % <span class="number">10</span>];</span><br><span class="line">y /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt1 == cnt2)<span class="keyword">return</span> flg;</span><br><span class="line"><span class="keyword">return</span> cnt1 &lt; cnt2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a, a + n, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p8732-蓝桥杯-2020-国-abc-答疑---洛谷"><ahref="https://www.luogu.com.cn/problem/P8732">P8732 [蓝桥杯 2020 国 ABC]答疑 - 洛谷</a></h2><p>知识点：贪心</p><p>排序往往不是单独的考点，而是作为贪心题目的实现方式。所谓贪心是将待处理的数据按照一定的顺序进行排列，贪心地处理局部最优，从而实现全局最优。要对数组排列，就需要一种满足题意的排序方式，这种方式不同于之前的题目是直接给出的，而是需要我们进行推导的。一种常见的思考方式是“微扰法”，即只考虑相邻两项在交换前和交换后的两种代价，通过假定某种代价更优，找到cmp 函数的不等式写法。</p><p>本题中考虑相邻的学生为 则交换前两位同学的总代价为：</p><p><span class="math display">\[(s_i + a_i)+(s_{i} + a_{i} + e_{i} + s_{i + 1} + a_{i + 1})\]</span></p><p>交换后的总代价为：</p><p><span class="math display">\[s_{i + 1} + a_{i + 1}+(s_{i + 1} + a_{i + 1} + e_{i+1} + s_{i} + a_{i})\]</span></p><p>不妨假设交换前更优，则有：</p><p><span class="math display">\[\begin{aligned}&amp;(s_i + a_i)+(s_{i} + a_{i} + e_{i} + s_{i + 1} + a_{i + 1})&amp;&lt;&amp; \ s_{i + 1} + a_{i + 1}+(s_{i + 1} + a_{i + 1} + e_{i+1}+ s_{i} + a_{i})\\&amp;2s_i + 2a_i + e_{i} + s_{i + 1} + a_{i + 1} &amp;&lt;&amp; \ 2s_{i+ 1} + 2a_{i + 1} + e_{i+1} + s_{i} + a_{i}\\&amp;s_i + a_i + e_{i} &amp;&lt;&amp; \ s_{i + 1} + a_{i + 1} + e_{i+1}\end{aligned}\]</span></p><p>因此得到 cmp 函数的写法为将的和较小的靠前放这一结论，这便是排序方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">贪心</span></span><br><span class="line"><span class="comment">要求发送消息的时刻最小，微扰法分析</span></span><br><span class="line"><span class="comment">微扰：是用相邻两项进行交换从而验证两项其中的一个怎么样才会使得最后答案最优，并以此确定排序方式的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">ll s, a, e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span><span class="number">+9</span>;</span><br><span class="line">ll n, ans, now;</span><br><span class="line">node st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x.s + x.a + x.e) &lt; (y.s + y.a + y.e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 显然谁的总耗时更长谁应该更晚进入</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; st[i].s &gt;&gt; st[i].a &gt;&gt; st[i].e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(st, st + n, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">ans += now + st[i].s + st[i].a;<span class="comment">// 第 i 位同学发送消息的时刻不包括 st[i].e</span></span><br><span class="line">now += st[i].s + st[i].a + st[i].e;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b3623-枚举排列递归实现排列型枚举---洛谷"><ahref="https://www.luogu.com.cn/problem/B3623">B3623枚举排列（递归实现排列型枚举） - 洛谷</a></h2><p>知识点：深搜枚举集合，next_permutation 与去重</p><p>深搜过程以 <span class="math inline">\(n=3,k=2\)</span> 举例：</p><p><img src="dfs_image.png" title="n = 3 , k = 2" alt="img" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)ans.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> t : ans) &#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">// 此处顺序枚举保证了字典序</span></span><br><span class="line"><span class="keyword">if</span> (vis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">vis[i] = <span class="number">1</span>;</span><br><span class="line">ans.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="built_in">dfs</span>();</span><br><span class="line">ans.<span class="built_in">pop_back</span>();</span><br><span class="line">vis[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">dfs</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;string&gt; s;<span class="comment">// 去重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">a[i] = i + <span class="number">1</span>; <span class="comment">// 初始化数组为1到n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(a.begin(), a.begin() + k)</span></span>; <span class="comment">// 截取前 k 个数字</span></span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> t : tmp) &#123;</span><br><span class="line">str += t + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">count</span>(str))<span class="keyword">continue</span>;</span><br><span class="line">s.<span class="built_in">insert</span>(str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> t : tmp) &#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>())); <span class="comment">// 生成下一个排列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="p8599-蓝桥杯-2013-省-b-带分数---洛谷"><ahref="https://www.luogu.com.cn/problem/P8599">P8599 [蓝桥杯 2013 省 B]带分数 - 洛谷</a></h2><p>知识点：next_permutation 用法，字符串划分，字符串转数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;<span class="comment">// 最大可表示 10^16</span></span><br><span class="line"><span class="type">int</span> ans, len;</span><br><span class="line">ll n;</span><br><span class="line">string s;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n = a + b/c &lt;-&gt; n * c = a * c + b</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ll <span class="title">str_to_num</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">// 左闭右闭</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = l;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 左侧高位写法</span></span><br><span class="line">ans = ans*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 对每个情况都切出三个数字，因此只需要两个标记，但要保证有三个数字</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a = <span class="built_in">str_to_num</span>(<span class="number">0</span>,i), b = <span class="built_in">str_to_num</span>(i<span class="number">+1</span>,j), c = <span class="built_in">str_to_num</span>(j<span class="number">+1</span>,len<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ( n * c == a * c + b)ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">s = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">len = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">check</span>();</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()));</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p10385-蓝桥杯-2024-省-a-艺术与篮球---洛谷"><ahref="https://www.luogu.com.cn/problem/P10385">P10385 [蓝桥杯 2024 省 A]艺术与篮球 - 洛谷</a></h2><p>知识点：c++ 手写日历，python 日期相关模块的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;<span class="comment">// 最大可表示 10^16</span></span><br><span class="line"><span class="comment">// 字符向数字映射</span></span><br><span class="line"><span class="type">int</span> mp[] = &#123;<span class="number">13</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">2000</span>, m = <span class="number">1</span>, d = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> day[] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闰年闰月判断</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (m==<span class="number">2</span>) &amp;&amp; ((y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>) || y % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">tmp += mp[a % <span class="number">10</span>];</span><br><span class="line">a /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">tmp += mp[b % <span class="number">10</span>];</span><br><span class="line">b /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">tmp += mp[c % <span class="number">10</span>];</span><br><span class="line">c /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp &gt; <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(y, m, d))ans++;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">2024</span> &amp;&amp; m == <span class="number">4</span> &amp;&amp; d == <span class="number">13</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 日期变化</span></span><br><span class="line">d++;</span><br><span class="line"><span class="keyword">if</span>(d&gt;day[m]+<span class="built_in">add</span>())</span><br><span class="line">&#123;</span><br><span class="line">d = <span class="number">1</span>;</span><br><span class="line">m++;</span><br><span class="line"><span class="keyword">if</span>(m&gt;<span class="number">12</span>)</span><br><span class="line">&#123;</span><br><span class="line">m = <span class="number">1</span>;</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义映射数组</span></span><br><span class="line">mp = [<span class="number">13</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义检查函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">y, m, d</span>):</span><br><span class="line">    tmp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> digit <span class="keyword">in</span> <span class="built_in">str</span>(y):// 转化为字符串后逐个映射</span><br><span class="line">        tmp += mp[<span class="built_in">int</span>(digit)]</span><br><span class="line">    <span class="keyword">for</span> digit <span class="keyword">in</span> <span class="built_in">str</span>(m).zfill(<span class="number">2</span>):// 对字符串零填充</span><br><span class="line">        tmp += mp[<span class="built_in">int</span>(digit)]</span><br><span class="line">    <span class="keyword">for</span> digit <span class="keyword">in</span> <span class="built_in">str</span>(d).zfill(<span class="number">2</span>):</span><br><span class="line">        tmp += mp[<span class="built_in">int</span>(digit)]</span><br><span class="line">    <span class="keyword">return</span> tmp &gt; <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化起始日期和结束日期</span></span><br><span class="line">start_date = datetime(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">end_date = datetime(<span class="number">2024</span>, <span class="number">4</span>, <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化答案计数</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历日期</span></span><br><span class="line">current_date = start_date</span><br><span class="line"><span class="keyword">while</span> current_date &lt;= end_date:</span><br><span class="line">    <span class="keyword">if</span> check(current_date.year, current_date.month, current_date.day):</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line">    current_date += timedelta(days=<span class="number">1</span>)// 更新日期</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h2 id="p8772-蓝桥杯-2022-省-a-求和---洛谷"><ahref="https://www.luogu.com.cn/problem/P8772">P8772 [蓝桥杯 2022 省 A]求和 - 洛谷</a></h2><p>知识点：前缀和、推式子</p><p>原始式子为：</p><p><span class="math display">\[S = a_1(a_2 + a_3 + \cdots + a_n) + a_2(a_3 + \cdots + a_n) + \cdots +a_{n - 1}a_n\]</span></p><p>如果暴力求每一项，则总的时间复杂度为 。</p><p>观察到每一项乘积其实是 <span class="math inline">\(a_i\)</span> 与<span class="math inline">\(\sum_{k=1}^n a_k - \sum_{k=1}^i a_k\)</span>的积，而此处的求和式子可以用前缀和维护从而避免每次都循环计算，将求每项的复杂度从降为 。推导出新的式子为：</p><p><span class="math display">\[S = \sum_{i = 1}^{n}\left( a_{i} \times (\sum_{k = 1}^{n} a_{k} -\sum_{k = 1}^{i} a_{k})\right)\]</span></p><p>新式子的时间复杂度为外层求和，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">2e5</span><span class="number">+9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll a[N],s[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) s[i] = a[i];</span><br><span class="line">        <span class="keyword">else</span> s[i] += s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = s[n];<span class="comment">//所有数的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += a[i]*(sum - s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p8708-蓝桥杯-2020-省-a1-整数小拼接---洛谷"><ahref="https://www.luogu.com.cn/problem/P8708">P8708 [蓝桥杯 2020 省 A1]整数小拼接 - 洛谷</a></h2><p>知识点：双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"></span><br><span class="line">ll n, k;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+9</span>;</span><br><span class="line"></span><br><span class="line">ll a[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 库函数实现数字拼接</span></span><br><span class="line"><span class="comment">//return stoll(to_string(a[i])+to_string(a[j]))&lt;=k;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手写</span></span><br><span class="line">ll x = a[i], y = a[j];</span><br><span class="line"><span class="keyword">while</span> (y) &#123;</span><br><span class="line">x *= <span class="number">10</span>, y /= <span class="number">10</span>; <span class="comment">// x 前移给 y 留出位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x + a[j] &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先保证有序</span></span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>, r = n; <span class="comment">// 双指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 不能是同一个数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(l, r)) &#123;</span><br><span class="line"><span class="comment">// 合法，说明这个 l 之后（l+1）到 r 的数字按照 l,r 的顺序拼接都合法</span></span><br><span class="line">ans += r - l;</span><br><span class="line">l++;<span class="comment">// 左边界移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> r--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意反向拼接也合法</span></span><br><span class="line">l = <span class="number">1</span>, r = n;<span class="comment">// 重新赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(r, l)) &#123; <span class="comment">// 只需要交换拼接的方式</span></span><br><span class="line">ans += r - l;</span><br><span class="line">l++;</span><br><span class="line">&#125; <span class="keyword">else</span> r--;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计竞赛 </category>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计竞赛 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
